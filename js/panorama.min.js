function PRingBufferGeometry(e, t, i, n, o, r) {
	THREE.BufferGeometry.call(this),
	this.type = "PRingBufferGeometry",
	this.parameters = {
		innerRadius: e,
		outerRadius: t,
		thetaSegments: i,
		phiSegments: n,
		thetaStart: o,
		thetaLength: r
	},
	e = e || 20,
	t = t || 50,
	o = void 0 !== o ? o: 0,
	r = void 0 !== r ? r: 2 * Math.PI,
	i = void 0 !== i ? Math.max(3, i) : 8,
	n = void 0 !== n ? Math.max(1, n) : 1;
	var a, s, l, c = (i + 1) * (n + 1),
	u = i * n * 2 * 3,
	h = new THREE.BufferAttribute(new(u > 65535 ? Uint32Array: Uint16Array)(u), 1),
	d = new THREE.BufferAttribute(new Float32Array(3 * c), 3),
	m = new THREE.BufferAttribute(new Float32Array(3 * c), 3),
	p = new THREE.BufferAttribute(new Float32Array(2 * c), 2),
	A = 0,
	f = 0,
	v = e,
	g = (t - e) / n,
	E = new THREE.Vector3,
	_ = new THREE.Vector2,
	w = 1 / n,
	y = 1 / i;
	for (s = 0; s <= n; s++) {
		for (l = 0; l <= i; l++) a = o + l / i * r,
		E.x = v * Math.cos(a),
		E.y = v * Math.sin(a),
		d.setXYZ(A, E.x, E.y, E.z),
		m.setXYZ(A, 0, 0, 1),
		_.x = l * y,
		_.y = s * w,
		p.setXY(A, _.x, _.y),
		A++;
		v += g
	}
	for (s = 0; s < n; s++) {
		var T = s * (i + 1);
		for (l = 0; l < i; l++) {
			a = l + T;
			var M = a,
			P = a + i + 1,
			b = a + i + 2,
			R = a + 1;
			h.setX(f, M),
			f++,
			h.setX(f, P),
			f++,
			h.setX(f, b),
			f++,
			h.setX(f, M),
			f++,
			h.setX(f, b),
			f++,
			h.setX(f, R),
			f++
		}
	}
	this.setIndex(h),
	this.addAttribute("position", d),
	this.addAttribute("normal", m),
	this.addAttribute("uv", p)
}
function TouchPanner(e) {
	e || (e = window),
	e.addEventListener("touchstart", this.onTouchStart_.bind(this)),
	e.addEventListener("touchmove", this.onTouchMove_.bind(this)),
	e.addEventListener("touchend", this.onTouchEnd_.bind(this)),
	this.isTouching = !1,
	this.rotateStart = new MathUtil.Vector2,
	this.rotateEnd = new MathUtil.Vector2,
	this.rotateDelta = new MathUtil.Vector2,
	this.theta = 0,
	this.orientation = new MathUtil.Quaternion
}
function ComplementaryFilter(e) {
	this.kFilter = e,
	this.currentAccelMeasurement = new SensorSample,
	this.currentGyroMeasurement = new SensorSample,
	this.previousGyroMeasurement = new SensorSample,
	this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1),
	this.previousFilterQ = new MathUtil.Quaternion,
	this.accelQ = new MathUtil.Quaternion,
	this.isOrientationInitialized = !1,
	this.estimatedGravity = new MathUtil.Vector3,
	this.measuredGravity = new MathUtil.Vector3,
	this.gyroIntegralQ = new MathUtil.Quaternion
}
function PosePredictor(e) {
	this.predictionTimeS = e,
	this.previousQ = new MathUtil.Quaternion,
	this.previousTimestampS = null,
	this.deltaQ = new MathUtil.Quaternion,
	this.outQ = new MathUtil.Quaternion
}
function SensorSample(e, t) {
	this.set(e, t)
}
function FusionPoseSensor(e) {
	this.deviceId = "webvr-polyfill:fused",
	this.deviceName = "VR Position Device (webvr-polyfill:fused)",
	this.accelerometer = new MathUtil.Vector3,
	this.gyroscope = new MathUtil.Vector3,
	this.rotRate_orientation = {
		alpha: 0,
		beta: 0,
		gamma: 0
	},
	this.rotCurrent_orientation = {
		alpha: 0,
		beta: 0,
		gamma: 0
	},
	window.addEventListener("orientationchange", this.onScreenOrientationChange_.bind(this)),
	window.addEventListener("devicemotion", this.onDeviceMotionChange_.bind(this)),
	this.rotationFix = {
		alpha: 0,
		beta: 0,
		gamma: 0
	},
	this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER),
	this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S),
	this.touchPanner = new TouchPanner(e),
	this.filterToWorldQ = new MathUtil.Quaternion,
	Util.isIOS() ? this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2),
	this.inverseWorldToScreenQ = new MathUtil.Quaternion,
	this.worldToScreenQ = new MathUtil.Quaternion,
	this.originalPoseAdjustQ = new MathUtil.Quaternion,
	this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -window.orientation * MathUtil.degToRad),
	this.setScreenTransform_(),
	Util.isLandscapeMode() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ),
	this.resetQ = new MathUtil.Quaternion,
	this.isFirefoxAndroid = Util.isFirefoxAndroid(),
	this.isIOS = Util.isIOS(),
	this.orientationOut_ = new Float32Array(4)
}
function OrientationSensor(e) {
	var t = this;
	this.enabled = !0,
	this.deviceOrientation = {},
	this.screenOrientation = 0,
	this.alphaOffsetAngle = 0,
	this.orientationOut_ = new Float32Array(4),
	this.quaternion = new THREE.Quaternion;
	var i = function(e) {
		t.deviceOrientation = e
	},
	n = function() {
		t.screenOrientation = window.orientation || 0
	};
	n(),
	window.addEventListener("orientationchange", n, !1),
	window.addEventListener("deviceorientation", i, !1);
	var o = function() {
		var e = new THREE.Vector3(0, 0, 1),
		t = new THREE.Euler,
		i = new THREE.Quaternion,
		n = new THREE.Quaternion,
		o = new THREE.Quaternion( - Math.sqrt(.5), 0, 0, Math.sqrt(.5));
		return function(r, a, s, l, c) {
			t.set(s, a, -l, "YXZ"),
			n.setFromEuler(t),
			n.multiply(o),
			n.multiply(i.setFromAxisAngle(e, -c)),
			r.slerp(n, .35)
		}
	} ();
	t.getOrientation = function() {
		var e = t.deviceOrientation.alpha ? THREE.Math.degToRad(t.deviceOrientation.alpha) + this.alphaOffsetAngle: 0,
		i = t.deviceOrientation.beta ? THREE.Math.degToRad(t.deviceOrientation.beta) : 0,
		n = t.deviceOrientation.gamma ? THREE.Math.degToRad(t.deviceOrientation.gamma) : 0,
		r = t.screenOrientation ? THREE.Math.degToRad(t.screenOrientation) : 0;
		return o(t.quaternion, e, i, n, r),
		this.orientationOut_[0] = t.quaternion.x,
		this.orientationOut_[1] = t.quaternion.y,
		this.orientationOut_[2] = t.quaternion.z,
		this.orientationOut_[3] = t.quaternion.w,
		this.orientationOut_
	},
	t.resetPose = function() {}
} !
function(e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof exports ? module.exports = e: e(jQuery)
} (function(e) {
	function t(t) {
		var a = t || window.event,
		s = l.call(arguments, 1),
		c = 0,
		h = 0,
		d = 0,
		m = 0,
		p = 0,
		A = 0;
		if (t = e.event.fix(a), t.type = "mousewheel", "detail" in a && (d = -1 * a.detail), "wheelDelta" in a && (d = a.wheelDelta), "wheelDeltaY" in a && (d = a.wheelDeltaY), "wheelDeltaX" in a && (h = -1 * a.wheelDeltaX), "axis" in a && a.axis === a.HORIZONTAL_AXIS && (h = -1 * d, d = 0), c = 0 === d ? h: d, "deltaY" in a && (d = -1 * a.deltaY, c = d), "deltaX" in a && (h = a.deltaX, 0 === d && (c = -1 * h)), 0 !== d || 0 !== h) {
			if (1 === a.deltaMode) {
				var f = e.data(this, "mousewheel-line-height");
				c *= f,
				d *= f,
				h *= f
			} else if (2 === a.deltaMode) {
				var v = e.data(this, "mousewheel-page-height");
				c *= v,
				d *= v,
				h *= v
			}
			if (m = Math.max(Math.abs(d), Math.abs(h)), (!r || r > m) && (r = m, n(a, m) && (r /= 40)), n(a, m) && (c /= 40, h /= 40, d /= 40), c = Math[c >= 1 ? "floor": "ceil"](c / r), h = Math[h >= 1 ? "floor": "ceil"](h / r), d = Math[d >= 1 ? "floor": "ceil"](d / r), u.settings.normalizeOffset && this.getBoundingClientRect) {
				var g = this.getBoundingClientRect();
				p = t.clientX - g.left,
				A = t.clientY - g.top
			}
			return t.deltaX = h,
			t.deltaY = d,
			t.deltaFactor = r,
			t.offsetX = p,
			t.offsetY = A,
			t.deltaMode = 0,
			s.unshift(t, c, h, d),
			o && clearTimeout(o),
			o = setTimeout(i, 200),
			(e.event.dispatch || e.event.handle).apply(this, s)
		}
	}
	function i() {
		r = null
	}
	function n(e, t) {
		return u.settings.adjustOldDeltas && "mousewheel" === e.type && t % 120 == 0
	}
	var o, r, a = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
	s = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
	l = Array.prototype.slice;
	if (e.event.fixHooks) for (var c = a.length; c;) e.event.fixHooks[a[--c]] = e.event.mouseHooks;
	var u = e.event.special.mousewheel = {
		version: "3.1.12",
		setup: function() {
			if (this.addEventListener) for (var i = s.length; i;) this.addEventListener(s[--i], t, !1);
			else this.onmousewheel = t;
			e.data(this, "mousewheel-line-height", u.getLineHeight(this)),
			e.data(this, "mousewheel-page-height", u.getPageHeight(this))
		},
		teardown: function() {
			if (this.removeEventListener) for (var i = s.length; i;) this.removeEventListener(s[--i], t, !1);
			else this.onmousewheel = null;
			e.removeData(this, "mousewheel-line-height"),
			e.removeData(this, "mousewheel-page-height")
		},
		getLineHeight: function(t) {
			var i = e(t),
			n = i["offsetParent" in e.fn ? "offsetParent": "parent"]();
			return n.length || (n = e("body")),
			parseInt(n.css("fontSize"), 10) || parseInt(i.css("fontSize"), 10) || 16
		},
		getPageHeight: function(t) {
			return e(t).height()
		},
		settings: {
			adjustOldDeltas: !0,
			normalizeOffset: !0
		}
	};
	e.fn.extend({
		mousewheel: function(e) {
			return e ? this.bind("mousewheel", e) : this.trigger("mousewheel")
		},
		unmousewheel: function(e) {
			return this.unbind("mousewheel", e)
		}
	})
}),
function(e) {
	var t = /iPhone/i,
	i = /iPod/i,
	n = /iPad/i,
	o = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,
	r = /Android/i,
	a = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
	s = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
	l = /IEMobile/i,
	c = /(?=.*\bWindows\b)(?=.*\bARM\b)/i,
	u = /BlackBerry/i,
	h = /BB10/i,
	d = /Opera Mini/i,
	m = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
	p = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,
	A = new RegExp("(?:Nexus 7|BNTV250|Kindle Fire|Silk|GT-P1000)", "i"),
	f = function(e, t) {
		return e.test(t)
	},
	v = function(e) {
		var v = e || navigator.userAgent,
		g = v.split("[FBAN");
		return void 0 !== g[1] && (v = g[0]),
		g = v.split("Twitter"),
		void 0 !== g[1] && (v = g[0]),
		this.apple = {
			phone: f(t, v),
			ipod: f(i, v),
			tablet: !f(t, v) && f(n, v),
			device: f(t, v) || f(i, v) || f(n, v)
		},
		this.amazon = {
			phone: f(a, v),
			tablet: !f(a, v) && f(s, v),
			device: f(a, v) || f(s, v)
		},
		this.android = {
			phone: f(a, v) || f(o, v),
			tablet: !f(a, v) && !f(o, v) && (f(s, v) || f(r, v)),
			device: f(a, v) || f(s, v) || f(o, v) || f(r, v)
		},
		this.windows = {
			phone: f(l, v),
			tablet: f(c, v),
			device: f(l, v) || f(c, v)
		},
		this.other = {
			blackberry: f(u, v),
			blackberry10: f(h, v),
			opera: f(d, v),
			firefox: f(p, v),
			chrome: f(m, v),
			device: f(u, v) || f(h, v) || f(d, v) || f(p, v) || f(m, v)
		},
		this.seven_inch = f(A, v),
		this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch,
		this.phone = this.apple.phone || this.android.phone || this.windows.phone,
		this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet,
		"undefined" == typeof window ? this: void 0
	},
	g = function() {
		var e = new v;
		return e.Class = v,
		e
	};
	"undefined" != typeof module && module.exports && "undefined" == typeof window ? module.exports = v: "undefined" != typeof module && module.exports && "undefined" != typeof window ? module.exports = g() : "function" == typeof define && define.amd ? define("isMobile", [], e.isMobile = g()) : e.isMobile = g()
} (this),
THREE.upgradeGeoObject = function(e) {
	for (var t = 0; e.materials && t < e.materials.length; t++) {
		var i = e.materials[t];
		i.transparency && (i.opacity = i.transparency, delete i.transparency),
		i.colorAmbient && delete i.colorAmbient
	}
},
function() {
	function e() {
		this.isPolyfilled = !0,
		this.displayId = t++,
		this.displayName = "webvr-polyfill displayName",
		this.isConnected = !0,
		this.isPresenting = !1,
		this.capabilities = {
			hasPosition: !1,
			hasOrientation: !1,
			hasExternalDisplay: !1,
			canPresent: !1,
			maxLayers: 1
		},
		this.stageParameters = null,
		this.waitingForPresent_ = !1,
		this.layer_ = null,
		this.fullscreenElement_ = null,
		this.fullscreenWrapper_ = null,
		this.fullscreenEventTarget_ = null,
		this.fullscreenChangeHandler_ = null,
		this.fullscreenErrorHandler_ = null,
		this.presentModeClassName = "WEBVR_POLYFILL_PRESENT"
	}
	var t = 1e3,
	i = !1;
	e.prototype.getPose = function() {
		return this.getImmediatePose()
	},
	e.prototype.requestAnimationFrame = function(e) {
		return window.requestAnimationFrame(e)
	},
	e.prototype.cancelAnimationFrame = function(e) {
		return window.cancelAnimationFrame(e)
	},
	e.prototype.wrapForFullscreen = function(e) {
		if (Util.isIOS()) return e;
		if (this.fullscreenWrapper_ || (this.fullscreenWrapper_ = document.createElement("div"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper"), this.fullscreenWrapper_.style.width = "100%", this.fullscreenWrapper_.style.height = "100%"), this.fullscreenElement_ == e) return this.fullscreenWrapper_;
		this.removeFullscreenWrapper(),
		this.fullscreenElement_ = e;
		var t = this.fullscreenElement_.parentElement;
		return t.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_),
		t.removeChild(this.fullscreenElement_),
		this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild),
		this.fullscreenWrapper_
	},
	e.prototype.removeFullscreenWrapper = function() {
		if (this.fullscreenElement_) {
			var e = this.fullscreenElement_;
			this.fullscreenElement_ = null;
			var t = this.fullscreenWrapper_.parentElement;
			return this.fullscreenWrapper_.removeChild(e),
			t.insertBefore(e, this.fullscreenWrapper_),
			t.removeChild(this.fullscreenWrapper_),
			e
		}
	},
	e.prototype.requestPresent = function(e) {
		var t = this;
		return e instanceof Array || (i || (console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers."), i = !0), e = [e]),
		new Promise(function(i, n) {
			function o() {
				var e = Util.getFullscreenElement();
				t.isPresenting = a === e,
				t.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary"), t.waitingForPresent_ = !1, t.beginPresent_(), t.setForceCanvasFullscreen_(!0), i()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), t.setForceCanvasFullscreen_(!1), t.removeFullscreenWrapper(), t.endPresent_(), t.removeFullscreenListeners_()),
				t.fireVRDisplayPresentChange_()
			}
			function r() {
				t.waitingForPresent_ && (t.removeFullscreenWrapper(), t.removeFullscreenListeners_(), t.waitingForPresent_ = !1, t.isPresenting = !1, n(new Error("Unable to present.")))
			}
			if (!t.capabilities.canPresent) return void n(new Error("VRDisplay is not capable of presenting."));
			if (0 == e.length || e.length > t.capabilities.maxLayers) return void n(new Error("Invalid number of layers."));
			if (t.layer_ = e[0], t.waitingForPresent_ = !1, t.layer_ && t.layer_.source) {
				var a = t.wrapForFullscreen(t.layer_.source);
				t.addFullscreenListeners_(a, o, r),
				Util.requestFullscreen(a) ? t.waitingForPresent_ = !0 : Util.isIOS() && (t.isPresenting = !0, t.beginPresent_(), t.fireVRDisplayPresentChange_(), i())
			}
			t.waitingForPresent_ || Util.isIOS() || (Util.exitFullscreen(), n(new Error("Unable to present.")))
		})
	},
	e.prototype.exitPresent = function() {
		var e = this.isPresenting,
		t = this;
		return this.isPresenting = !1,
		this.layer_ = null,
		new Promise(function(i, n) {
			e ? (!Util.exitFullscreen() && Util.isIOS() && (t.endPresent_(), t.fireVRDisplayPresentChange_()), i()) : n(new Error("Was not presenting to VRDisplay."))
		})
	},
	e.prototype.getLayers = function() {
		return this.layer_ ? [this.layer_] : []
	},
	e.prototype.fireVRDisplayPresentChange_ = function() {
		var e = new CustomEvent("vrdisplaypresentchange", {
			detail: {
				vrdisplay: this
			}
		});
		window.dispatchEvent(e)
	},
	e.prototype.addFullscreenListeners_ = function(e, t, i) {
		this.removeFullscreenListeners_(),
		this.fullscreenEventTarget_ = e,
		this.fullscreenChangeHandler_ = t,
		this.fullscreenErrorHandler_ = i,
		t && (e.addEventListener("fullscreenchange", t, !1), e.addEventListener("webkitfullscreenchange", t, !1), document.addEventListener("mozfullscreenchange", t, !1), e.addEventListener("msfullscreenchange", t, !1)),
		i && (e.addEventListener("fullscreenerror", i, !1), e.addEventListener("webkitfullscreenerror", i, !1), document.addEventListener("mozfullscreenerror", i, !1), e.addEventListener("msfullscreenerror", i, !1))
	},
	e.prototype.removeFullscreenListeners_ = function() {
		if (this.fullscreenEventTarget_) {
			var e = this.fullscreenEventTarget_;
			if (this.fullscreenChangeHandler_) {
				var t = this.fullscreenChangeHandler_;
				e.removeEventListener("fullscreenchange", t, !1),
				e.removeEventListener("webkitfullscreenchange", t, !1),
				document.removeEventListener("mozfullscreenchange", t, !1),
				e.removeEventListener("msfullscreenchange", t, !1)
			}
			if (this.fullscreenErrorHandler_) {
				var i = this.fullscreenErrorHandler_;
				e.removeEventListener("fullscreenerror", i, !1),
				e.removeEventListener("webkitfullscreenerror", i, !1),
				document.removeEventListener("mozfullscreenerror", i, !1),
				e.removeEventListener("msfullscreenerror", i, !1)
			}
			this.fullscreenEventTarget_ = null,
			this.fullscreenChangeHandler_ = null,
			this.fullscreenErrorHandler_ = null
		}
	},
	e.prototype.beginPresent_ = function() {},
	e.prototype.endPresent_ = function() {},
	e.prototype.submitFrame = function(e) {},
	e.prototype.getEyeParameters = function(e) {
		return null
	},
	e.prototype.setForceCanvasFullscreen_ = function(e) {
		e ? this.fullscreenElement_.classList.add(this.presentModeClassName) : this.fullscreenElement_.classList.remove(this.presentModeClassName)
	},
	window.VRDisplay = e
} (),
function() {
	function e(e) {
		l = this,
		this.displayName = "Mouse and Keyboard VRDisplay (webvr-polyfill)",
		this.capabilities.hasOrientation = !0,
		this.panDamping = .15,
		this.panDampingEnabled = !0,
		this.panEnabled = !0,
		this.STANDARD = 0,
		this.BORDER = 1,
		this.panType = this.STANDARD,
		this.phi_ = 0,
		this.phi_i = 0,
		this.theta_ = 0,
		this.theta_i = 0,
		this.targetAngle_ = null,
		this.angleAnimation_ = null,
		this.orientation_ = new MathUtil.Quaternion,
		this.rotateStart_ = new MathUtil.Vector2,
		this.rotateEnd_ = new MathUtil.Vector2,
		this.rotateDelta_ = new MathUtil.Vector2,
		this.isDragging_ = !1,
		this.orientationOut_ = new Float32Array(4),
		this.zoomEnabled = !0,
		this.zoomMin = 0,
		this.zoomMax = 1,
		this.zoom = this.zoomMax,
		this.zoom_i = this.zoom,
		this.zoomSpeed = .1,
		this.zoomDamping = .15,
		this.attach(e)
	}
	function t(e, t) {
		l.panEnabled && (l.rotateStart_.set(e, t), l.isDragging_ = !0)
	}
	function i(e, t) {
		if (l.panEnabled) {
			g.x = e,
			g.y = t;
			var i = l.zoom / l.zoomMax;
			l.rotateEnd_.set(e, t),
			l.rotateDelta_.subVectors(l.rotateEnd_, l.rotateStart_),
			l.rotateStart_.copy(l.rotateEnd_),
			l.panType == l.STANDARD && (l.phi_ += c * l.rotateDelta_.y / screen.height * d * i, l.theta_ += c * l.rotateDelta_.x / screen.width * h * i),
			l.phi_ = Util.clamp(l.phi_, -u, u)
		}
	}
	function n() {
		l.isDragging_ = !1
	}
	function o(e) {
		l.zoomEnabled && (f = e, v = a(e))
	}
	function r(e) {
		if (l.zoomEnabled) {
			var t = a(e);
			s(.1 * -(t - v)),
			v = t,
			f = e
		}
	}
	function a(e) {
		var t = e[0],
		i = e[1],
		n = t.clientX - i.clientX,
		o = t.clientY - i.clientY;
		return Math.sqrt(n * n + o * o)
	}
	function s(e) {
		l.zoom = Math.max(l.zoomMin, Math.min(l.zoomMax, l.zoom + e))
	}
	var l, c = 2 * Math.PI,
	u = Math.PI / 2,
	h = .5,
	d = .3;
	e.prototype = new window.VRDisplay;
	var m, p = $(window);
	e.prototype.attach = function(e) {
		m = e,
		m.on("keydown", this.onKeyDown_.bind(this)),
		m.on("mousedown", this.onMouseDown_),
		m.on("mousemove", this.onMouseMove_),
		m.on("mouseup", this.onMouseUp_),
		p.on("mouseout", this.onWindowOut_),
		m.on("mousewheel", this.onMouseWheel_),
		m.on("touchstart", this.onTouchDown_),
		m.on("touchmove", this.onTouchMove_),
		m.on("touchend", this.onTouchEnd_)
	},
	e.prototype.detach = function() {
		m.off("keydown", this.onKeyDown_),
		m.off("mousedown", this.onMouseDown_),
		m.off("mousemove", this.onMouseMove_),
		m.off("mouseup", this.onMouseUp_),
		p.off("mouseout", this.onWindowOut_),
		m.off("touchstart", this.onTouchDown_),
		m.off("touchmove", this.onTouchMove_),
		m.off("touchend", this.onTouchEnd_)
	},
	e.prototype.getImmediatePose = function() {
		return this.orientation_.setFromEulerYXZ(this.phi_i, this.theta_i, 0),
		this.orientationOut_[0] = this.orientation_.x,
		this.orientationOut_[1] = this.orientation_.y,
		this.orientationOut_[2] = this.orientation_.z,
		this.orientationOut_[3] = this.orientation_.w,
		{
			position: null,
			orientation: this.orientationOut_,
			linearVelocity: null,
			linearAcceleration: null,
			angularVelocity: null,
			angularAcceleration: null
		}
	},
	e.prototype.animateTheta_ = function(e) {
		this.animateKeyTransitions_("theta_", e)
	},
	e.prototype.animatePhi_ = function(e) {
		e = Util.clamp(e, -u, u),
		this.animateKeyTransitions_("phi_", e)
	},
	e.prototype.animateKeyTransitions_ = function(e, t) {
		this.angleAnimation_ && clearInterval(this.angleAnimation_);
		var i = this[e],
		n = new Date;
		this.angleAnimation_ = setInterval(function() {
			var o = new Date - n;
			if (o >= 80) return this[e] = t,
			void clearInterval(this.angleAnimation_);
			var r = o / 80;
			this[e] = i + (t - i) * r
		}.bind(this), 1e3 / 60)
	},
	e.prototype.isPointerLocked_ = function() {
		return void 0 !== (document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement)
	},
	e.prototype.resetPose = function() {
		this.phi_ = 0,
		this.theta_ = 0
	};
	var A = new THREE.Euler;
	e.prototype.setOrientation = function(e) {
		A.setFromQuaternion(e, "YXZ"),
		this.phi_ = this.phi_i = A.x,
		this.theta_ = this.theta_i = A.y
	},
	e.prototype.update = function(e) {
		if (this.zoom_i += (this.zoom - this.zoom_i) * this.zoomDamping, this.panEnabled) {
			if (this.panType == this.BORDER) {
				var t = l.zoom / l.zoomMax,
				i = Util.normalizedToClampedDirections(g.y / window.innerHeight, .5);
				l.phi_ -= .2 * i * d * t;
				var n = Util.normalizedToClampedDirections(g.x / window.innerWidth, .5);
				l.theta_ -= .05 * n * h * t
			}
			this.panDampingEnabled ? (this.phi_i += (this.phi_ - this.phi_i) * this.panDamping, this.theta_i += (this.theta_ - this.theta_i) * this.panDamping) : (this.phi_i = this.phi_, this.theta_i = this.theta_),
			l.phi_ = Util.clamp(l.phi_, -u, u)
		}
	};
	var f, v, g = {
		x: 0,
		y: 0
	};
	e.prototype.enableZoom = function(e) {
		e ? l.zoomEnabled = !0 : l.zoomEnabled && (l.zoomEnabled = !1, l.zoom = l.zoomMax)
	},
	e.prototype.onMouseWheel_ = function(e) {
		l.zoomEnabled && s(e.deltaY * l.zoomSpeed)
	},
	e.prototype.onKeyDown_ = function(e) {
		38 == e.keyCode ? this.animatePhi_(this.phi_ + .15) : 39 == e.keyCode ? this.animateTheta_(this.theta_ - .15) : 40 == e.keyCode ? this.animatePhi_(this.phi_ - .15) : 37 == e.keyCode && this.animateTheta_(this.theta_ + .15)
	},
	e.prototype.onMouseDown_ = function(e) {
		e.preventDefault(),
		t(e.clientX, e.clientY)
	},
	e.prototype.onMouseMove_ = function(e) { (l.isDragging_ || l.isPointerLocked_()) && (e.preventDefault(), i(e.clientX, e.clientY))
	},
	e.prototype.onMouseUp_ = function(e) {
		e.preventDefault(),
		n()
	},
	e.prototype.onWindowOut_ = function(e) {
		e.preventDefault(),
		l.isDragging_ = !1
	};
	var E = {
		NONE: 0,
		PAN: 1,
		SCALE: 2
	},
	_ = E.NONE;
	e.prototype.onTouchDown_ = function(e) {
		e.preventDefault();
		var i = e.originalEvent.touches;
		switch (i.length) {
		case 1:
			_ = E.PAN;
			var n = i[0];
			t(n.clientX, n.clientY);
			break;
		case 2:
			_ = E.SCALE,
			o(i)
		}
	},
	e.prototype.onTouchMove_ = function(e) {
		e.preventDefault();
		var t = e.originalEvent.touches;
		switch (_) {
		case E.PAN:
			var n = t[0];
			i(n.clientX, n.clientY);
			break;
		case E.SCALE:
			r(t)
		}
	},
	e.prototype.onTouchEnd_ = function(e) {
		e.preventDefault();
		var i = e.originalEvent.touches;
		switch (i.length) {
		case 1:
			_ = E.PAN;
			var n = i[0];
			t(n.clientX, n.clientY);
			break;
		default:
			_ = E.NONE
		}
	},
	window.MouseKeyboardVRDisplay = e
} ();
var PNRM = PNRM || {};
PNRM.MouseTracker = function(e) {
	function t(e) {
		Util.getEventCursorPosition(e, r),
		l.x = r.x,
		l.y = r.y,
		n(),
		o.moved_distance = 0
	}
	function i(e) {
		o.setFromEvent(e)
	}
	function n() {
		dx = Math.abs(a.x - r.x),
		dy = Math.abs(a.y - r.y),
		o.moved_distance += dx * dx + dy * dy,
		s.x = r.x / c.width() * 2 - 1,
		s.y = -r.y / c.height() * 2 + 1,
		a.x = r.x,
		a.y = r.y
	}
	var o = this,
	r = {
		x: 0,
		y: 0
	},
	a = this.mouse = {
		x: 0,
		y: 0
	},
	s = this.centered_mouse = {
		x: -2,
		y: -2
	},
	l = this.mouse_start = {
		x: 0,
		y: 0
	};
	this.moved_distance = 0;
	var c = $(e);
	return Util.addEvent("down", c, t),
	Util.addEvent("move", c, i),
	o.resetMouse = function() {
		r.x = r.y = a.x = a.y = 0,
		s.x = s.x = -2,
		s.y = s.y = -2
	},
	o.setFromEvent = function(e) {
		Util.getEventCursorPosition(e, r),
		n()
	},
	o.hasMovement = function() {
		return o.moved_distance >= 1
	},
	this
};
var PNRM = PNRM || {},
PNRM_PLAYER = {};
PNRM.Player = function(e, t, i) {
	function n() {
		if (!_) {
			if (l.getState() == l.STATES.IDLE) {
				y.update();
				var e = y.zoom_i;
				e != g.fov && (g.fov = e, g.updateProjectionMatrix()),
				l.updateOrientation(),
				g.quaternion.fromArray(T),
				l.hover_enabled && P.checkHover()
			}
			l.getState() != l.STATES.IDLE && l.getState() != l.STATES.ANIMATED || (l.isVR() ? R.render() : m.render(d, g), f && f.update(m)),
			v = window.requestAnimationFrame(n)
		}
	}
	function o(e) {
		e.rotationRate && (e.rotationRate.alpha || e.rotationRate.beta || e.rotationRate.gamma) && (window.removeEventListener("devicemotion", o), l.gyroPresent = !0, l.poseSensor_ = new FusionPoseSensor(p[0]))
	}
	function r(e) {
		l.panorama_current = e,
		E.getTexture(l.panorama_current,
		function() {
			E.fadeIn(a)
		})
	}
	function a() {
		if (g.fov = h, g.updateProjectionMatrix(), l.isVR() && P.showCrosshair(), l.panorama_current.points) for (var e = 0; e < l.panorama_current.points.length; e++) {
			var t = l.panorama_current.points[e];
			P.addPointer(t)
		}
		l.setState(l.STATES.IDLE)
	}
	function s() {
		x.enable(),
		document.removeEventListener("touchstart", s, !1)
	}
	var l = this;
	l.is_editor = i,
	l.path_gui = "images/gui/";
	var c = ($("<div class='debug'>").appendTo($("body")), l.$container = $(e));
	Detector.webgl,
	PNRM_PLAYER = l,
	(l.GUI = t).init();
	l.getVersion = function() {
		return "0.1"
	},
	l.is_mobile = Util.isMobile(),
	l.hover_enabled = !0,
	l.onPointerCreated = void 0,
	l.onPointerOver = void 0,
	l.onPointerOut = void 0,
	l.onPointerClick = void 0;
	var u, h;
	u = 30,
	h = 75,
	l.SPHERE_DIAMETER = 500,
	l.POINT_DISTANCE = l.SPHERE_DIAMETER / 2 * .7;
	var d = l.scene = new THREE.Scene,
	m = l.renderer = new THREE.WebGLRenderer({
		powerPreference: "high-performance"
	});
	l.pixel_ratio = window.devicePixelRatio || 1,
	m.setPixelRatio(l.pixel_ratio),
	m.setSize(window.innerWidth, window.innerHeight);
	var p = l.$canvas = $(m.domElement);
	c.prepend(p);
	var A = m.context;
	l.MAX_TEXTURE_SIZE = 8192,
	l.device_max_texture_size = A.getParameter(A.MAX_TEXTURE_SIZE) || l.MAX_TEXTURE_SIZE;
	var f, v, g = l.camera = new THREE.PerspectiveCamera(h, window.innerWidth / window.innerHeight, .1, 700),
	E = l.panoGeometry = new PNRM.PanoGeometry(d, l.SPHERE_DIAMETER, l.device_max_texture_size),
	_ = !1,
	w = !1;
	m.domElement.addEventListener("webglcontextlost",
	function() {
		w || ($(c).trigger("animate:stop"), $(c).trigger("animate:start")),
		w = !1
	}),
	$(c).on("animate:start",
	function() {
		_ = !1,
		$(m.domElement).remove(),
		m = l.renderer = new THREE.WebGLRenderer({
			powerPreference: "high-performance"
		}),
		l.pixel_ratio = 1,
		m.setPixelRatio(l.pixel_ratio),
		m.setSize(window.innerWidth, window.innerHeight),
		p = l.$canvas = $(m.domElement),
		c.prepend(p),
		m.domElement.addEventListener("webglcontextlost",
		function() {
			w || ($(c).trigger("animate:stop"), $(c).trigger("animate:start")),
			w = !1
		});
		var e = m.context;
		l.MAX_TEXTURE_SIZE = 8192,
		l.device_max_texture_size = e.getParameter(e.MAX_TEXTURE_SIZE) || l.MAX_TEXTURE_SIZE,
		n()
	}),
	$(c).on("animate:stop",
	function() {
		w = !0,
		_ = !0,
		m.setPixelRatio(1),
		l.pixel_ratio = 1,
		window.cancelAnimationFrame(v),
		m.clear(!0, !0, !0),
		m.dispose(),
		$(m.domElement).length && (window.navigator.userAgent.indexOf("MSIE ") > 0 || window.navigator.userAgent.match(/Trident.*rv\:11\./) || m.context.isContextLost() || m.forceContextLoss(), $(m.domElement).remove())
	});
	var y = l.mouseSensor_ = new window.MouseKeyboardVRDisplay(p);
	y.zoomMin = u,
	y.zoomMax = h,
	y.zoom = h,
	y.zoom_i = h,
	y.zoomSpeed = 3,
	l.gyroPresent = !1,
	l.MOUSE = 1,
	l.TOUCH = 2,
	l.control_type = l.MOUSE;
	var T;
	l.orientationSensor_ = new OrientationSensor(p[0]);
	l.switchControls = function(e, t) {
		e == l.ORIENTATION ? (l.updateOrientation = function() {
			T = l.orientationSensor_.getOrientation()
		},
		l.POINTERS.mouse_mode = !1) : (l.POINTERS.mouse_mode = !0, l.updateOrientation = function() {
			T = y.getImmediatePose().orientation
		},
		l.updateSensorOrientation = function(e) {
			y.setOrientation(e)
		}),
		t ? l.mouseSensor_.enableZoom(!1) : l.mouseSensor_.enableZoom(!0)
	},
	l.getControlsType = function() {
		return T == l.poseSensor_ ? l.ORIENTATION: l.MOUSE
	},
	l.STATES = {
		LOADING: 0,
		INACTIVE: 1,
		IDLE: 2,
		ANIMATED: 3,
		SAVING: 4
	};
	var M = l.STATES.LOADING;
	l.setState = function(e) {
		M = e
	},
	l.getState = function(e) {
		return M
	},
	l.setState(l.STATES.LOADING),
	l.panorama_current = void 0;
	var P = l.POINTERS = new PNRM.Pointers(l);
	l.get2dPointerPosition = P.get2dPointerPosition,
	l.removePointer = P.removePointer,
	l.attachElementToPointer = P.attachElementToPointer,
	l.dettachElementFromPointer = P.dettachElementFromPointer,
	l.dettachElementFromPointers = P.dettachElementFromPointers,
	l.addPointer = P.addPointer,
	l.createPointerByMousePosition = P.createPointerByMousePosition,
	l.movePointerToMousePosition = P.movePointerToMousePosition,
	l.loadData = function(e) {
		$.ajax({
			dataType: "json",
			url: e,
			success: r,
			error: function(e) {
				console.log("Error", e)
			}
		})
	},
	l.createPanorama = function(e, t, i) {
		var n;
		n = E.SPHERE,
		l.panorama_current = {
			image: l.device_max_texture_size < l.MAX_TEXTURE_SIZE ? e.image_mob: e.image,
			name: void 0,
			type: n,
			points: e.points,
			uploaded: e.images
		},
		window.earthDemo && window.earthDemo.running && l.device_max_texture_size >= l.MAX_TEXTURE_SIZE && (l.panorama_current.image = e.image_small),
		E.getTexture(l.panorama_current,
		function(e) {
			E.fadeIn(a),
			t && t(e)
		}),
		i || P.removePointers()
	};
	var b = !1;
	if (l.isFullScreen = function() {
		return b
	},
	l.fullscreenToggle = function(e) {
		var t = $("body")[0];
		e || void 0 == e && !Util.getFullscreenElement() ? (Util.requestFullscreen(t), $("#pnrm_button_fullscreen").removeClass("pano__button_fullscreen_off").addClass("pano__button_fullscreen_off"), b = !0) : (Util.exitFullscreen(), $("#pnrm_button_fullscreen").addClass("pano__button_fullscreen_off").removeClass("pano__button_fullscreen_off"), b = !1)
	},
	PNRM.VR) var R = l.VR = new PNRM.VR;
	l.isVR = function() {
		return R && R.isVR()
	};
	var x = new NoSleep;
	document.addEventListener("touchstart", s, !1);
	var S;
	l.onWindowResize = function() {
		clearTimeout(S),
		S = setTimeout(function() {
			var e = c.innerWidth(),
			t = c.innerHeight();
			g.aspect = e / t,
			g.updateProjectionMatrix(),
			m.setSize(e, t),
			l.isVR() && R.setSize(e, t)
		},
		200)
	},
	$(window).on("resize", l.onWindowResize),
	function(e) {
		l.switchControls(e),
		window.addEventListener("devicemotion", o)
	} (l.TOUCH),
	n(),
	l.onWindowResize()
},
PNRM.parseData = function(e) {
	for (var t = [], i = 0; i < e.length; i++) {
		for (var n = e[i], o = [], r = 0; r < n.points.length; r++) {
			var a = n.points[r],
			s = new PNRM.Point(a.x, a.y, a.z, a.panorama_id);
			o.push(s)
		}
		var l = new PNRM.Panorama({
			is_first_panorama: n.is_first_panorama,
			panorama_id: n.panorama_id,
			name: n.name,
			type: n.type,
			orientation_x: n.orientation_x,
			orientation_y: n.orientation_y,
			orientation_z: n.orientation_z,
			image: n.image,
			preview: n.preview,
			points: o
		});
		t[n.panorama_id] = l
	}
	return t
},
PNRM.COLOR_ORANGE = "#ff5722";
var PNRM = PNRM || {};
PNRM.PanoGeometry = function(e, t, i) {
	function n(t) {
		for (var i = 0; i < f.materials.length; i++) {
			var n = f.materials[i];
			n.map.image = t[i],
			n.map.needsUpdate = !0
		}
		e.add(v),
		v.updateMatrix()
	}
	function o(t) {
		var i = g.map;
		i.image = t,
		i.needsUpdate = !0,
		e.add(E),
		E.updateMatrix()
	}
	function r(e, t) {
		var i = e.image,
		n = e.type;
		switch (console.log("getTexture: ", i, n, e.image_state), e.image_state) {
		case w:
			e.image_load_callbacks.push(t);
			break;
		case y:
			s(e),
			t(e);
			break;
		case _:
		default:
			a(e, t)
		}
	}
	function a(e, t) {
		function i(t) {
			if (0 == --r && (e.image_state = y, e.image_load_callbacks)) for (var i = 0; i < e.image_load_callbacks.length; i++) {
				var n = e.image_load_callbacks[i];
				n && n(e)
			}
		}
		var n = e.image,
		o = e.type;
		e.image_state = w,
		e.image_load_callbacks = [],
		e.image_load_callbacks.push(t),
		e.images || (e.images = []);
		var r = 0;
		if (o == c.CUBE) if (e.uploaded) {
			console.log(" uploaded cube ", e.uploaded);
			for (var a = 0; a < e.uploaded.length; a++) {
				r++;
				for (var s = e.uploaded[a], l = u.load(s.img, i), h = 0; h < m.length; h++) {
					var d = s.name.split("_")[1].split(".")[0];
					if (m[h] == d) {
						e.images[h] = l;
						break
					}
				}
			}
			e.uploaded = void 0
		} else for (var p = n.lastIndexOf("."), A = n.substr(0, p), v = n.substr(p, n.length), a = 0; a < f.materials.length; a++) {
			r++;
			var g = A + m[a] + v,
			l = u.load(g, i);
			e.images.push(l)
		} else if (e.uploaded) {
			r++;
			var l = u.load(e.uploaded[0].img, i);
			e.images.push(l),
			e.uploaded = void 0
		} else {
			r++;
			var l = u.load(n, i);
			e.images.push(l)
		}
	}
	function s(e) {
		c.panorama_type = e.type,
		c.panorama_type == c.CUBE ? n(e.images) : o(e.images[0])
	}
	function l(e) {
		if (h.r = e, h.g = e, h.b = e, c.panorama_type == c.CUBE) for (var t = 0; t < d.length; t++) d[t].color = h;
		else g.color = h
	}
	var c = this;
	c.CUBE = "cube",
	c.SPHERE = "sphere",
	c.panorama_type;
	for (var u = new THREE.ImageLoader,
	h = new THREE.Color(16777215), d = [], m = ["r", "l", "t", "d", "f", "b"], p = 0; p < m.length; p++) {
		var A = new THREE.MeshBasicMaterial({
			color: 0,
			map: new THREE.Texture
		});
		d.push(A)
	}
	var f = new THREE.MeshFaceMaterial(d),
	v = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1, 4, 4, 4), f);
	v.scale.set( - t, t, t),
	v.matrixAutoUpdate = !1;
	var g = new THREE.MeshBasicMaterial({
		color: 0,
		map: new THREE.Texture
	}),
	E = new THREE.Mesh(new THREE.SphereBufferGeometry(1, 64, 64), g);
	E.scale.set( - t, t, t),
	E.matrixAutoUpdate = !1;
	var _ = 0,
	w = 1,
	y = 2;
	this.getTexture = function(e, t) {
		r(e,
		function() {
			s(e),
			t(e)
		})
	},
	c.fade_progress,
	this.fadeIn = function(e) {
		c.fade_progress = 0,
		Util.animateValue(c, "fade_progress", void 0, 1, 300,
		function() {
			e && e()
		},
		function() {
			l(c.fade_progress)
		})
	},
	this.fadeOut = function(t) {
		Util.animateValue(c, "fade_progress", void 0, 0, 300,
		function() {
			e.remove(v),
			e.remove(E),
			t && t()
		},
		function() {
			l(c.fade_progress)
		})
	}
};
var PNRM = PNRM || {};
PNRM.Pointers = function() {
	function e(e) {
		if (n.is_editor) return void(i.INTERSECTED ? n.onPointerClick && n.onPointerClick(i.INTERSECTED) : i.createPointerByMousePosition(!0));
		Util.isMobile() && !n.isVR() && (m.setFromEvent(e), i.checkHover(), m.resetMouse()),
		i.click_enabled && (e && n.isVR() && !i.use_vr_tap || n.getState() == n.STATES.IDLE && i.INTERSECTED && (i.selected_pointer = i.INTERSECTED, m.hasMovement() && !n.isVR() || i.goToSelectedPoint()))
	}
	function t(e) {
		var t = {
			x: e.x,
			y: e.y,
			z: e.z
		},
		o = i.addPointer(t);
		return n.onPointerCreated && n.onPointerCreated(o),
		o
	}
	var i = this,
	n = PNRM_PLAYER,
	o = n.camera,
	r = n.scene,
	a = (n.engine, $(n.renderer.domElement));
	i.selected_pointer = null;
	var s = i.container = new THREE.Object3D;
	s.matrixAutoUpdate = !1,
	r.add(s),
	this.mouse_mode = !0,
	i.use_vr_tap = !1,
	i.click_enabled = !0,
	this.pointers = [],
	this.demoPointers = [];
	var l = i.assets = [],
	c = new PNRM.VRHover(o);
	r.add(c.sprite);
	var u = new PNRM.Crosshair;
	r.add(u.sprite),
	u.sprite.parent = o,
	this.showCrosshair = u.show,
	this.hideCrosshair = u.hide,
	this.addPointer = function(e) {
		var t;
		t = l.length ? l.pop() : e.approved_works > 0 ? new PNRM.Pointer("#e1cf2d") : new PNRM.Pointer;
		var o = n.panorama_current;
		return t.activate(e, s, o.locationVisited),
		i.pointers.push(t),
		i.demoPointers.push(t),
		t
	},
	this.removePointers = function() {
		for (var e = 0; e < i.pointers.length; e++) {
			var t = i.pointers[e];
			t.deactivate(),
			l.push(t)
		}
		i.pointers = []
	},
	this.removePointer = function(e) {
		if (e) {
			var t = i.pointers.indexOf(e); - 1 != t && (i.pointers.splice(t, 1), l.push(e), e.deactivate())
		}
	};
	var h;
	this.setActivePointer = function(e, t) {
		if (!e) return void(h && (c.hide(), h.hideHover(), h = void 0));
		h && h == e || (h = e, h.showHover())
	},
	i.raycaster = new THREE.Raycaster;
	var d = {
		x: 0,
		y: 0
	},
	m = new PNRM.MouseTracker(n.renderer.domElement);
	Util.addEvent("up", a, e),
	this.INTERSECTED = null,
	this.checkHover = function() {
		if (i.pointers.length) for (var t = n.$container.width(), r = n.$container.height(), l = 0; l < i.pointers.length; l++) {
			var c = i.pointers[l],
			u = c.gui_elements;
			if (u.length) for (var h = 0; h < u.length; h++) {
				var p = u[h],
				A = Util.get2dPosition(c.sprite.getWorldPosition(), n.camera, t, r);
				A.z < 1 ? (p.style.display = "block", p.style.left = A.x + "px", p.style.top = A.y + "px") : p.style.display = "none"
			}
			c.update(o.position.clone())
		}
		i.raycaster.setFromCamera(i.mouse_mode ? m.centered_mouse: d, o);
		var f = i.raycaster.intersectObjects(s.children, !1);
		if (f.length > 0) {
			var v = f[0].object.pointer;
			i.INTERSECTED != v && (i.INTERSECTED = v, n.isVR() ? i.setActivePointer(i.INTERSECTED, e) : !Util.isMobile() && i.INTERSECTED && (i.INTERSECTED.showHover(), a.css("cursor", "pointer")))
		} else i.INTERSECTED && (n.isVR() ? i.setActivePointer() : Util.isMobile() || (i.INTERSECTED.hideHover(), a.css("cursor", "auto"))),
		i.INTERSECTED = null
	};
	i.get2dPointerPosition = function(e) {
		if (e) {
			var t = n.$container.width(),
			i = n.$container.height();
			return pos = Util.get2dPosition(e.sprite.getWorldPosition(), n.camera, t, i)
		}
	},
	i.attachElementToPointer = function(e, t, n) {
		e && (n && i.dettachElementFromPointers(t), e.gui_elements.push(t))
	},
	i.dettachElementFromPointer = function(e, t) {
		if (e) {
			var i = e.gui_elements;
			if (i.length) {
				var n = i.indexOf(t); - 1 != n && i.splice(n, 1)
			}
		}
	},
	i.dettachElementFromPointers = function(e) {
		for (var t = 0; t < i.pointers.length; t++) {
			var n = i.pointers[t],
			o = n.gui_elements;
			if (o.length) {
				var r = o.indexOf(e); - 1 != r && o.splice(r, 1)
			}
		}
	};
	var p = new THREE.Object3D,
	A = new THREE.Quaternion,
	f = new THREE.Quaternion,
	v = new THREE.Quaternion(0, 1, 0, 0),
	g = new THREE.Vector3(0, 0, 0),
	E = new THREE.Vector3(0, 0, 0);
	this.stopLookAtPointer = function() {
		n.setState(n.STATES.IDLE),
		n.mouseSensor_.panDampingEnabled = !0,
		n.mouseSensor_.panEnabled = !0
	},
	this.lookAtPointer = function(e, t, i) {
		A.copy(n.camera.quaternion),
		p.lookAt(e.sprite.position),
		f.copy(p.quaternion),
		f.multiply(v),
		g.set(0, 0, 0),
		E.set(0, 0, 0),
		u && u.sprite.localToWorld(g),
		g.normalize(),
		e.sprite.localToWorld(E),
		E.normalize();
		var o = i ? ~~ (1e3 * g.distanceTo(E)) * i: 3 * ~~ (1e3 * g.distanceTo(E));
		n.setState(n.STATES.ANIMATED),
		n.mouseSensor_.panDampingEnabled = !1,
		n.mouseSensor_.panEnabled = !1,
		Util.animateQuaternion(n.camera.quaternion, A, f, o,
		function() {
			t && t(),
			n.updateSensorOrientation(n.camera.quaternion)
		})
	},
	this.goToSelectedPoint = function() {
		function e(e) {
			i.stopLookAtPointer(),
			window.location.assign(e)
		}
		if (!i.selected_pointer) return void console.warn("where's no selected point");
		var t = i.selected_pointer.point_data.link;
		if (t) {
			var n;
			switch (typeof t) {
			case "function":
				n = t();
				break;
			case "string":
			case "number":
			case "boolean":
				break;
			default:
				n = t
			}
			i.lookAtPointer(i.selected_pointer,
			function() {
				n ? n.done(function(t) {
					e(kaspersky.brief_page_link(t))
				}) : e(t)
			},
			!1)
		}
	},
	this.lookAtPointerByAxis = function(e, t, i) {
		function o(t) {
			A.copy(n.camera.quaternion);
			var o = e.sprite.position.clone();
			"x" === t ? o.setY(n.camera.position.getComponent(1)) : "y" === t && o.setX(n.camera.position.getComponent(0)),
			p.lookAt(o),
			f.copy(p.quaternion),
			f.multiply(v),
			g.set(0, 0, 0),
			E.set(0, 0, 0),
			u && u.sprite.localToWorld(g),
			g.normalize(),
			e.sprite.localToWorld(E),
			E.normalize();
			var r = i ? ~~ (1e3 * g.distanceTo(E)) * i: 1.5 * ~~ (1e3 * g.distanceTo(E));
			return n.setState(n.STATES.ANIMATED),
			n.mouseSensor_.panDampingEnabled = !1,
			n.mouseSensor_.panEnabled = !1,
			{
				rot_start: A,
				rot_end: f,
				speed: r
			}
		}
		var r = o("x");
		Util.animateQuaternion(n.camera.quaternion, r.rot_start, r.rot_end, r.speed,
		function() {
			n.updateSensorOrientation(n.camera.quaternion);
			var e = o();
			Util.animateQuaternion(n.camera.quaternion, e.rot_start, e.rot_end, e.speed,
			function() {
				t && t(),
				n.updateSensorOrientation(n.camera.quaternion)
			})
		})
	},
	PNRM.demoZoom = this.demoZoom = function(e, t, i) {
		t ? n.camera.zoomDefault = n.camera.zoom: t = n.camera.zoomDefault;
		var o = n.camera.zoom,
		r = t - n.camera.zoom;
		n.camera._anim_progress_ = 0,
		$(n.camera).stop().animate({
			_anim_progress_: 1
		},
		{
			duration: e,
			step: function(e, t) {
				n.camera.zoom = o + r * e,
				n.camera.updateProjectionMatrix()
			},
			complete: function() { !! i && i()
			}
		})
	},
	PNRM.demoMoveToPoint = this.demoMoveToPoint = function(e, t) {
		e || (e = i.demoPointers[2]),
		t ? i.lookAtPointerByAxis(e,
		function() {
			i.demoZoom(500, 2)
		},
		!1) : i.lookAtPointer(e,
		function() {
			i.demoZoom(500, 2)
		},
		!1)
	},
	PNRM.demoMoveFromPoint = this.demoMoveToPoint = function() {
		i.demoZoom(500, !1,
		function() {
			i.stopLookAtPointer()
		})
	},
	PNRM.demoRotateByAxis = this.demoRotateByAxis = function(e, t, o, r) {
		for (var a = 0,
		s = [0, 0], l = 0, c = 0; c < e.length; c++) if (0 !== c) {
			var h = e[c][0] || e[c][1];
			h = Math.abs(h),
			l += h
		}
		PNRM.startAnim = function() {
			0 === a && i.demoZoom(0, 1),
			A.copy(n.camera.quaternion);
			var c = [s[0] + e[a][0], s[1] + e[a][1]];
			p.lookAt(n.camera.position.clone().applyQuaternion(n.camera.quaternion)),
			p.rotateY( - c[0] * Math.PI / 180).rotateX(c[1] * Math.PI / 180),
			f.copy(p.quaternion),
			s = c;
			var h = e[a][0] || e[a][1];
			h = Math.abs(h),
			g.set(0, 0, 0),
			E.set(0, 0, 0),
			u && u.sprite.localToWorld(g),
			g.normalize(),
			E.normalize();
			var d = t || h / l * 1e3 * (r || 14);
			0 !== a && 0 !== t || (d = 0),
			n.setState(n.STATES.ANIMATED),
			n.mouseSensor_.panDampingEnabled = !1,
			n.mouseSensor_.panEnabled = !1,
			Util.animateQuaternion(n.camera.quaternion, A, f, d,
			function() {
				n.updateSensorOrientation(n.camera.quaternion),
				n.camera.updateProjectionMatrix(),
				e[a][2] ? i.demoZoom(1500, e[a][2],
				function() {
					a === e.length - 1 ? (a++, a < e.length ? PNRM.startAnim() : o && o()) : setTimeout(function() {
						i.demoZoom(500, !1,
						function() {
							a++,
							a < e.length ? PNRM.startAnim() : o && o()
						})
					},
					1e3)
				}) : (a++, a < e.length ? PNRM.startAnim() : o && o())
			},
			"linear")
		},
		PNRM.startAnim()
	},
	i.movePointerToMousePosition = function(e, t) {
		if (e && (!t || !m.hasMovement())) {
			i.raycaster.setFromCamera(m.centered_mouse, o);
			var r = i.raycaster.ray.at(n.POINT_DISTANCE);
			e.sprite.position.copy(r)
		}
	},
	i.createPointerByMousePosition = function(e) {
		if (!e || !m.hasMovement()) {
			i.raycaster.setFromCamera(m.centered_mouse, o);
			return t(i.raycaster.ray.at(n.POINT_DISTANCE))
		}
	}
},
PNRM.Point = function(e, t, i, n) {
	this.x = e || 0,
	this.y = t || 0,
	this.z = i || 0,
	this.panorama_id = n || 0
};
var PNRM = PNRM || {};
PNRM.Pointer = function(e) {
	function t(e) {
		p.visible = !0,
		A._opacity = 0,
		A.opacity = A._opacity,
		p.scale.set(l, l, l),
		p.updateMatrix()
	}
	function i(e) {
		var t, i, n;
		e ? (t = 0, i = 1) : (t = 1, i = 0),
		n = v / 2 / 1e3,
		h._a_progress = t;
		var o = h.map.repeat,
		r = h.map.offset;
		TweenLite.killTweensOf(d[0]),
		TweenLite.to(d[0], n, {
			_a_progress: i,
			ease: Back.easeOut,
			onUpdate: function() {
				var e = .2 * h._a_progress;
				r.x = r.y = -e / 2,
				o.x = o.y = 1 + e
			}
		})
	}
	function n(e) {
		var t = "400 16px MuseoSans";
		E.font = t,
		E.textAlign = "left",
		E.textBaseline = "middle";
		for (var i = 0,
		n = [], r = 0, a = 0; a < e.length; a++) {
			var s = e[a],
			l = E.measureText(s).width;
			l > r && (r = l),
			n[a] = l,
			i += 19.2
		}
		var c = ~~ (r + 24);
		g.width = c,
		g.height = i + 2,
		E.font = t,
		E.textAlign = "left",
		E.textBaseline = "middle",
		E.fillStyle = "rgba(0,0,0,0.8)",
		o(E, 1, 1, r - 2 + 24, 19.2 * e.length + 1, 6, !0);
		for (var a = 0; a < e.length; a++) {
			var s = e[a],
			u = 19.2 * a,
			l = (a == e.length - 1 ? n[a] : r) + 24;
			E.fillStyle = "#00ffa7",
			E.fillText(s, 12, u + 9.6 + 2)
		}
		w.scale.set(.015 * c, .015 * i, 1),
		_.needsUpdate = !0
	}
	function o(e, t, i, n, o, r, a, s) {
		if (void 0 === s && (s = !0), void 0 === r && (r = 5), "number" == typeof r) r = {
			tl: r,
			tr: r,
			br: r,
			bl: r
		};
		else {
			var l = {
				tl: 0,
				tr: 0,
				br: 0,
				bl: 0
			};
			for (var c in l) r[c] = r[c] || l[c]
		}
		e.beginPath(),
		e.moveTo(t + r.tl, i),
		e.lineTo(t + n - r.tr, i),
		e.quadraticCurveTo(t + n, i, t + n, i + r.tr),
		e.lineTo(t + n, i + o - r.br),
		e.quadraticCurveTo(t + n, i + o, t + n - r.br, i + o),
		e.lineTo(t + r.bl, i + o),
		e.quadraticCurveTo(t, i + o, t, i + o - r.bl),
		e.lineTo(t, i + r.tl),
		e.quadraticCurveTo(t, i, t + r.tl, i),
		e.closePath(),
		a && e.fill(),
		s && e.stroke()
	}
	var r = PNRM_PLAYER,
	a = this;
	a.is_visited,
	a.container = void 0,
	a.anim_progress = 0,
	a.point_data = void 0,
	a.position = new THREE.Vector3;
	var s = new THREE.Vector3,
	l = 1.45,
	c = a.sprite = new THREE.Sprite,
	u = PNRM.Textures.getTexture(PNRM.Textures.POINTER, e),
	h = c.material = new THREE.SpriteMaterial({
		map: u
	}),
	d = $(h);
	c.pointer = a;
	var m = Util.isMobile() ? 30 : 20;
	c.scale.set(.01, .01, .01);
	var p = a.hover = function(t) {
		var i = new THREE.Sprite,
		n = PNRM.Textures.getTexture(t, e);
		return i.material = new THREE.SpriteMaterial({
			map: n
		}),
		c.add(i),
		i.visible = !1,
		i.scale.set(l, l, l),
		i.updateMatrix(),
		i
	} (PNRM.Textures.POINTER_HOVER),
	A = p.material,
	f = $(A);
	a.gui_elements = [],
	a.activate = function(e, i, o) {
		if (is_visited = o, e._visual_object = a, a.point_data = e, a.setPosition(e), a.container = i, a.container.add(c), t(), Util.animateVector(c.scale, .01, m, 200), e.name) {
			var r = kaspersky.trimText(e.name, 18, 10);
			n(e && e.approved_works > 0 ? r: r)
		}
	},
	a.setPosition = function(e) {
		var t = c.position;
		t.set(e.x, e.y, e.z),
		t.normalize().multiplyScalar(r.POINT_DISTANCE),
		a.position.copy(t),
		a.point_data.x = t.x,
		a.point_data.y = t.y,
		a.point_data.z = t.z,
		c.lookAt(c.worldToLocal(s))
	},
	a.deactivate = function() {
		Util.animateVector(c.scale, c.scale.clone(), .01, 200),
		gui_elements = [],
		f.stop(!0, !0)
	},
	a.update = function(e) {};
	var v = 200;
	a.showHover = function() {
		t(),
		f.finish().animate({
			_opacity: 1
		},
		{
			progress: function() {
				A.opacity = A._opacity
			},
			duration: v
		})
	},
	a.showHoverVR = function() {
		i(!0)
	},
	a.hideHover = function() {
		f.finish().animate({
			_opacity: 0
		},
		{
			progress: function() {
				A.opacity = A._opacity;
				var e = l + (1 - A._opacity) / 2;
				p.scale.set(e, e, e),
				p.updateMatrix()
			},
			duration: v,
			complete: function() {
				p.visible = !1
			}
		})
	},
	a.hideHoverVR = function() {
		i(!1)
	};
	var g = document.createElement("canvas"),
	E = g.getContext("2d"),
	_ = new THREE.Texture(g);
	_.generateMipmaps = !1,
	_.magFilter = THREE.LinearFilter,
	_.minFilter = THREE.LinearFilter,
	title_material = new THREE.SpriteMaterial({
		map: _
	});
	var w = new THREE.Sprite;
	return w.material = title_material,
	c.add(w),
	w.position.z = .01,
	w.position.y = -.7,
	w.visible = !0,
	a
};
var PNRM = PNRM || {};
PNRM.Textures = function() {
	function e(e, t, i, n, r) {
		var a = document.createElement("canvas");
		a.width = a.height = e;
		var s, l = a.getContext("2d"),
		c = e / 2,
		u = a.height / 2;
		s = n || o;
		var h = .5 * e * t;
		return l.beginPath(),
		l.lineWidth = i,
		l.strokeStyle = "#02FFA7",
		l.arc(c, u, h, 0, 2 * Math.PI),
		l.stroke(),
		l.closePath(),
		r && (l.save(), l.beginPath(), l.globalAlpha = .5, l.lineWidth = 3, l.strokeStyle = s, l.arc(c, u, h - 3, 0, 2 * Math.PI), l.stroke(), l.closePath(), l.restore(), l.save(), l.beginPath(), l.globalAlpha = .8, l.lineWidth = 2, l.strokeStyle = s, l.arc(c, u, h + 3, 0, 2 * Math.PI), l.stroke(), l.closePath(), l.restore(), l.save(), l.beginPath(), l.globalAlpha = .5, l.lineWidth = 2, l.strokeStyle = s, l.arc(c, u, h + 5, 0, 2 * Math.PI), l.stroke(), l.closePath(), l.restore()),
		new THREE.Texture(a)
	}
	function t(e) {
		var t = document.createElement("canvas");
		t.width = t.height = e;
		var i = t.getContext("2d"),
		n = e / 2,
		o = t.height / 2,
		s = e * r;
		return i.beginPath(),
		i.arc(n, o, s, 0, 2 * Math.PI, !1),
		i.fillStyle = "rgba(0, 0, 0, 0.6)",
		i.fill(),
		i.lineWidth = e * a,
		i.strokeStyle = "#ffffff",
		i.stroke(),
		new THREE.Texture(t)
	}
	var i = this,
	n = {};
	i.POINTER = 0,
	i.POINTER_HOVER = 1,
	i.POINTER_SELECTED = 2,
	i.POINTER_PROGRESS = 3,
	i.getTexture = function(o, r) {
		var a;
		switch (o) {
		case i.POINTER:
			a = e(80, .5, 4, r, !0);
			break;
		case i.POINTER_HOVER:
			a = e(80, .35, 8, r);
			break;
		case i.POINTER_SELECTED:
			a = t(128);
			break;
		case i.POINTER_PROGRESS:
			a = createPointerProgress(256)
		}
		return a ? (n[o] = a, a.needsUpdate = !0, a.generateMipalphaMaps = !1, a.magFilter = THREE.LinearFilter, a.minFilter = THREE.LinearFilter, n[o]) : (console.warn("can't find such texture: ", o), null)
	};
	var o = "#04aa73",
	r = .42,
	a = .029296875;
	return this
} ();
var PNRM = PNRM || {};
PNRM.GUI = function() {
	var e, t, i = this;
	i.GENERAL = 1,
	i.VR = 2,
	i.VR_SETTINGS = 3,
	i.init = function() {
		e = PNRM_PLAYER,
		t = e.$container
	},
	$(".addwork .modal__close-button").click(function() {
		window.history.back()
	}),
	$exitFullscreenButton = $(".panorama__fullscreen-exit-button").click(function() {
		i.showPreview(!1)
	}).hide();
	var n = !1;
	i.showPreview = function(i) {
		t.toggleClass("panorama_fullscreen", i),
		t.closest("body").toggleClass("fullscreen", i),
		e.fullscreenToggle(i),
		e.onWindowResize(),
		$exitFullscreenButton[i ? "show": "hide"](),
		n = i
	}
};
var MathUtil = window.MathUtil || {};
MathUtil.degToRad = Math.PI / 180,
MathUtil.radToDeg = 180 / Math.PI,
MathUtil.Vector2 = function(e, t) {
	this.x = e || 0,
	this.y = t || 0
},
MathUtil.Vector2.prototype = {
	constructor: MathUtil.Vector2,
	set: function(e, t) {
		return this.x = e,
		this.y = t,
		this
	},
	copy: function(e) {
		return this.x = e.x,
		this.y = e.y,
		this
	},
	subVectors: function(e, t) {
		return this.x = e.x - t.x,
		this.y = e.y - t.y,
		this
	}
},
MathUtil.Vector3 = function(e, t, i) {
	this.x = e || 0,
	this.y = t || 0,
	this.z = i || 0
},
MathUtil.Vector3.prototype = {
	constructor: MathUtil.Vector3,
	set: function(e, t, i) {
		return this.x = e,
		this.y = t,
		this.z = i,
		this
	},
	copy: function(e) {
		return this.x = e.x,
		this.y = e.y,
		this.z = e.z,
		this
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	},
	normalize: function() {
		var e = this.length();
		if (0 !== e) {
			var t = 1 / e;
			this.multiplyScalar(t)
		} else this.x = 0,
		this.y = 0,
		this.z = 0;
		return this
	},
	multiplyScalar: function(e) {
		this.x *= e,
		this.y *= e,
		this.z *= e
	},
	applyQuaternion: function(e) {
		var t = this.x,
		i = this.y,
		n = this.z,
		o = e.x,
		r = e.y,
		a = e.z,
		s = e.w,
		l = s * t + r * n - a * i,
		c = s * i + a * t - o * n,
		u = s * n + o * i - r * t,
		h = -o * t - r * i - a * n;
		return this.x = l * s + h * -o + c * -a - u * -r,
		this.y = c * s + h * -r + u * -o - l * -a,
		this.z = u * s + h * -a + l * -r - c * -o,
		this
	},
	dot: function(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z
	},
	crossVectors: function(e, t) {
		var i = e.x,
		n = e.y,
		o = e.z,
		r = t.x,
		a = t.y,
		s = t.z;
		return this.x = n * s - o * a,
		this.y = o * r - i * s,
		this.z = i * a - n * r,
		this
	}
},
MathUtil.Quaternion = function(e, t, i, n) {
	this.x = e || 0,
	this.y = t || 0,
	this.z = i || 0,
	this.w = void 0 !== n ? n: 1
},
MathUtil.Quaternion.prototype = {
	constructor: MathUtil.Quaternion,
	set: function(e, t, i, n) {
		return this.x = e,
		this.y = t,
		this.z = i,
		this.w = n,
		this
	},
	copy: function(e) {
		return this.x = e.x,
		this.y = e.y,
		this.z = e.z,
		this.w = e.w,
		this
	},
	setFromEulerXYZ: function(e, t, i) {
		var n = Math.cos(e / 2),
		o = Math.cos(t / 2),
		r = Math.cos(i / 2),
		a = Math.sin(e / 2),
		s = Math.sin(t / 2),
		l = Math.sin(i / 2);
		return this.x = a * o * r + n * s * l,
		this.y = n * s * r - a * o * l,
		this.z = n * o * l + a * s * r,
		this.w = n * o * r - a * s * l,
		this
	},
	setFromEulerYXZ: function(e, t, i) {
		var n = Math.cos(e / 2),
		o = Math.cos(t / 2),
		r = Math.cos(i / 2),
		a = Math.sin(e / 2),
		s = Math.sin(t / 2),
		l = Math.sin(i / 2);
		return this.x = a * o * r + n * s * l,
		this.y = n * s * r - a * o * l,
		this.z = n * o * l - a * s * r,
		this.w = n * o * r + a * s * l,
		this
	},
	setFromAxisAngle: function(e, t) {
		var i = t / 2,
		n = Math.sin(i);
		return this.x = e.x * n,
		this.y = e.y * n,
		this.z = e.z * n,
		this.w = Math.cos(i),
		this
	},
	multiply: function(e) {
		return this.multiplyQuaternions(this, e)
	},
	multiplyQuaternions: function(e, t) {
		var i = e.x,
		n = e.y,
		o = e.z,
		r = e.w,
		a = t.x,
		s = t.y,
		l = t.z,
		c = t.w;
		return this.x = i * c + r * a + n * l - o * s,
		this.y = n * c + r * s + o * a - i * l,
		this.z = o * c + r * l + i * s - n * a,
		this.w = r * c - i * a - n * s - o * l,
		this
	},
	inverse: function() {
		return this.x *= -1,
		this.y *= -1,
		this.z *= -1,
		this.normalize(),
		this
	},
	normalize: function() {
		var e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		return 0 === e ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (e = 1 / e, this.x = this.x * e, this.y = this.y * e, this.z = this.z * e, this.w = this.w * e),
		this
	},
	slerp: function(e, t) {
		if (0 === t) return this;
		if (1 === t) return this.copy(e);
		var i = this.x,
		n = this.y,
		o = this.z,
		r = this.w,
		a = r * e.w + i * e.x + n * e.y + o * e.z;
		if (a < 0 ? (this.w = -e.w, this.x = -e.x, this.y = -e.y, this.z = -e.z, a = -a) : this.copy(e), a >= 1) return this.w = r,
		this.x = i,
		this.y = n,
		this.z = o,
		this;
		var s = Math.acos(a),
		l = Math.sqrt(1 - a * a);
		if (Math.abs(l) < .001) return this.w = .5 * (r + this.w),
		this.x = .5 * (i + this.x),
		this.y = .5 * (n + this.y),
		this.z = .5 * (o + this.z),
		this;
		var c = Math.sin((1 - t) * s) / l,
		u = Math.sin(t * s) / l;
		return this.w = r * c + this.w * u,
		this.x = i * c + this.x * u,
		this.y = n * c + this.y * u,
		this.z = o * c + this.z * u,
		this
	},
	setFromUnitVectors: function() {
		var e, t;
		return function(i, n) {
			return void 0 === e && (e = new MathUtil.Vector3),
			t = i.dot(n) + 1,
			t < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set( - i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n),
			this.x = e.x,
			this.y = e.y,
			this.z = e.z,
			this.w = t,
			this.normalize(),
			this
		}
	} ()
};
var Util = window.Util || {};
Util.MIN_TIMESTEP = .001,
Util.MAX_TIMESTEP = 1,
Util.base64 = function(e, t) {
	return "data:" + e + ";base64," + t
},
Util.clamp = function(e, t, i) {
	return Math.min(Math.max(t, e), i)
},
Util.lerp = function(e, t, i) {
	return e + (t - e) * i
},
Util.isIOS = function() {
	var e = /iPad|iPhone|iPod/.test(navigator.platform);
	return function() {
		return e
	}
} (),
Util.isSafari = function() {
	var e = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	return function() {
		return e
	}
} (),
Util.isFirefoxAndroid = function() {
	var e = -1 !== navigator.userAgent.indexOf("Firefox") && -1 !== navigator.userAgent.indexOf("Android");
	return function() {
		return e
	}
} (),
Util.isLandscapeMode = function() {
	return 90 == window.orientation || -90 == window.orientation
},
Util.isTimestampDeltaValid = function(e) {
	return ! isNaN(e) && (!(e <= Util.MIN_TIMESTEP) && !(e > Util.MAX_TIMESTEP))
},
Util.getScreenWidth = function() {
	return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio
},
Util.getScreenHeight = function() {
	return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio
},
Util.requestFullscreen = function(e) {
	if (e.requestFullscreen) e.requestFullscreen();
	else if (e.webkitRequestFullscreen) e.webkitRequestFullscreen();
	else if (e.mozRequestFullScreen) e.mozRequestFullScreen();
	else {
		if (!e.msRequestFullscreen) return ! 1;
		e.msRequestFullscreen()
	}
	return ! 0
},
Util.exitFullscreen = function() {
	if (document.exitFullscreen) document.exitFullscreen();
	else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
	else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
	else {
		if (!document.msExitFullscreen) return ! 1;
		document.msExitFullscreen()
	}
	return ! 0
},
Util.getFullscreenElement = function() {
	return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement
},
Util.orthoMatrix = function(e, t, i, n, o, r, a) {
	var s = 1 / (t - i),
	l = 1 / (n - o),
	c = 1 / (r - a);
	return e[0] = -2 * s,
	e[1] = 0,
	e[2] = 0,
	e[3] = 0,
	e[4] = 0,
	e[5] = -2 * l,
	e[6] = 0,
	e[7] = 0,
	e[8] = 0,
	e[9] = 0,
	e[10] = 2 * c,
	e[11] = 0,
	e[12] = (t + i) * s,
	e[13] = (o + n) * l,
	e[14] = (a + r) * c,
	e[15] = 1,
	e
},
Util.isMobile = function() {
	var e = !1;
	return function(t) { (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
	} (navigator.userAgent || navigator.vendor || window.opera),
	e
},
Util.safariCssSizeWorkaround = function(e) {
	if (Util.isIOS()) {
		var t = e.style.width,
		i = e.style.height;
		e.style.width = parseInt(t) + 1 + "px",
		e.style.height = parseInt(i) + "px",
		console.log("Resetting width to...", t),
		setTimeout(function() {
			console.log("Done. Width is now", t),
			e.style.width = t,
			e.style.height = i
		},
		100)
	}
	window.Util = Util,
	window.canvas = e
},
Util.PI2 = 2 * Math.PI,
Util.PIh = Math.PI / 2,
Util.devicePixelRatio = window.devicePixelRatio || 1,
Util.normalizedToClampedDirections = function(e, t) {
	var i = 1 / (1 - t);
	return v = 2 * e - 1,
	v = v > 0 ? (Math.max(v, t) - t) * i: (Math.min(v, -t) + t) * i,
	v
},
Util.get2dPosition = function(e, t, i, n) {
	var o = e.clone().project(t);
	return o.x = (o.x + 1) / 2 * i,
	o.y = -(o.y - 1) / 2 * n,
	o
},
Util.nearestPOT = function(e) {
	return Math.pow(2, Math.round(Math.log(e) / Math.log(2)))
},
Util.FIT = 0,
Util.COVER = 1,
Util.CONTAIN = 2,
Util.POT = 3,
Util.JPEG = "image/jpeg",
Util.PNG = "image/png",
Util.imageLimitSize = function(e, t, i) {
	var n = document.createElement("img"),
	o = document.createElement("canvas"),
	r = o.getContext("2d");
	return function(e, t, i, a, s) {
		var l, c;
		return void 0 === a && (a = Util.CONTAIN),
		n.onload = function() {
			var u, h = n.width,
			d = n.height;
			if (console.log("imageLimitSize:", h + "(" + t + ")", d + "(" + i + ")", a), a != Util.POT && h <= t && d <= i) return console.log("imageLimitSize: image is in bounds - skip"),
			void("function" == typeof c && c(e));
			switch (a) {
			case Util.FIT:
				h = Math.min(h, t),
				d = Math.min(d, i);
				break;
			case Util.COVER:
				u = t / h,
				u * d < i && (u = i / d),
				h *= u,
				d *= u;
				break;
			case Util.CONTAIN:
				u = t / h,
				u * d > i && (u = i / d),
				h *= u,
				d *= u;
				break;
			case Util.POT:
				h = Util.nearestPOT(h),
				t && (h = Math.min(h, t)),
				d = Util.nearestPOT(d),
				i && (d = Math.min(d, i))
			}
			o.width = h,
			o.height = d,
			r.drawImage(n, 0, 0, h, d),
			console.log("imageLimitSize:", n.width + ">" + h, n.height + ">" + d),
			l = o.toDataURL(s || Util.JPEG),
			"function" == typeof c && c(l)
		},
		n.setAttribute("src", e),
		{
			done: function(e) {
				l && e(l),
				c = e
			}
		}
	}
} (),
Util.addEvent = function(e, t, i) {
	switch (e) {
	case "down":
		t.on("mousedown", i),
		t.on("touchstart", i);
		break;
	case "move":
		t.on("mousemove", i),
		t.on("touchmove", i);
		break;
	case "up":
		t.on("mouseup", i),
		t.on("touchend", i),
		t.on("touchcancel", i);
		break;
	case "click":
		t.on("click", i),
		t.on("tap", i)
	}
},
Util.removeEvent = function(e, t, i) {
	switch (e) {
	case "down":
		t.off("mousedown", i),
		t.off("touchstart", i);
		break;
	case "move":
		t.off("mousemove", i),
		t.off("touchmove", i);
		break;
	case "up":
		t.off("mouseup", i),
		t.off("touchend", i),
		t.off("touchcancel", i);
		break;
	case "click":
		t.off("click", i),
		t.off("tap", i)
	}
},
Util.getEventCursorPosition = function(e, t) {
	var i, n = e.originalEvent.touches;
	i = n ? n.length ? n[0] : e.originalEvent.changedTouches[0] : e.originalEvent;
	var o = void 0 != i.offsetX ? i.offsetX: i.clientX,
	r = void 0 != i.offsetY ? i.offsetY: i.clientY;
	return t ? (t.x = o, void(t.y = r)) : {
		x: o,
		y: r
	}
},
Util.animateVector = function(e, t, i, n, o) {
	"number" == typeof t && (t = new THREE.Vector3(t, t, t)),
	"number" == typeof i && (i = new THREE.Vector3(i, i, i)),
	e._anim_progress_ = 0,
	$(e).stop().animate({
		_anim_progress_: 1
	},
	{
		duration: n,
		progress: function() {
			e.lerpVectors(t, i, e._anim_progress_)
		},
		complete: function() {
			o && o()
		}
	})
},
Util.animateQuaternion = function(e, t, i, n, o, r) {
	"number" == typeof t && (t = new THREE.Quaternion(t, t, t, 0)),
	"number" == typeof i && (i = new THREE.Quaternion(i, i, i, 0)),
	e._anim_progress_ = 0,
	$(e).stop().animate({
		_anim_progress_: 1
	},
	{
		duration: n,
		easing: r || "swing",
		progress: function() {
			THREE.Quaternion.slerp(t, i, e, e._anim_progress_)
		},
		complete: function() {
			o && o()
		}
	})
},
Util.animateValue = function(e, t, i, n, o, r, a) {
	e._anim_progress_ = void 0 != i ? i: e[t],
	$(e).stop().animate({
		_anim_progress_: n
	},
	{
		duration: o,
		progress: function() {
			this[t] = this._anim_progress_,
			a && a()
		},
		complete: function() {
			r && r()
		}
	})
},
Util.lcg = function() {
	var e, t, i = 4294967296;
	return {
		setSeed: function(n) {
			t = e = n || Math.round(Math.random() * i)
		},
		getSeed: function() {
			return e
		},
		rand: function() {
			return (t = (1664525 * t + 1013904223) % i) / i
		}
	}
} (),
Util.lcg.setSeed(0),
Util.rand = Util.lcg.rand,
Util.generateGUID = function() {
	return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,
	function(e) {
		var t = 16 * Util.rand() | 0;
		return ("x" == e ? t: 3 & t | 8).toString(16)
	})
},
Util.generateGUID(),
Util.checkLocalStorage = function() {
	try {
		return "localStorage" in window && null !== window.localStorage
	} catch(e) {
		return ! 1
	}
},
Util.setLocalStorage = function(e, t) {
	return !! Util.checkLocalStorage() && (window.localStorage[e] = t, !0)
},
Util.getLocalStorage = function(e) {
	return Util.checkLocalStorage() ? window.localStorage[e] : null
},
function(e) {
	function t(e, t, i) {
		var n = document.createElement("source");
		n.src = i,
		n.type = "video/" + t,
		e.appendChild(n)
	}
	var i = {
		Android: /Android/gi.test(navigator.userAgent),
		iOS: /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent)
	},
	n = {
		WebM: "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=",
		MP4: "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=="
	},
	o = function() {
		return i.iOS ? this.noSleepTimer = null: i.Android && (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("loop", ""), t(this.noSleepVideo, "webm", n.WebM), t(this.noSleepVideo, "mp4", n.MP4)),
		this
	};
	o.prototype.enable = function(e) {
		i.iOS ? (this.disable(), this.noSleepTimer = window.setInterval(function() {
			window.location.href = "/",
			window.setTimeout(window.stop, 0)
		},
		e || 15e3)) : i.Android && this.noSleepVideo.play()
	},
	o.prototype.disable = function() {
		i.iOS ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : i.Android && this.noSleepVideo.pause()
	},
	e.NoSleep = o
} (this),
THREE.StereoEffect = function(e) {
	var t = new THREE.StereoCamera;
	t.aspect = .5,
	this.getEyeSeparation = function() {
		return t.eyeSep
	},
	this.setEyeSeparation = function(e) {
		t.eyeSep = e
	},
	this.setSize = function(t, i) {
		e.setSize(t, i)
	},
	this.render = function(i, n) {
		i.updateMatrixWorld(),
		null === n.parent && n.updateMatrixWorld(),
		t.update(n);
		var o = e.getSize();
		e.setScissorTest(!0),
		e.clear(),
		e.setScissor(0, 0, o.width / 2, o.height),
		e.setViewport(0, 0, o.width / 2, o.height),
		e.render(i, t.cameraL),
		e.setScissor(o.width / 2, 0, o.width / 2, o.height),
		e.setViewport(o.width / 2, 0, o.width / 2, o.height),
		e.render(i, t.cameraR),
		e.setScissorTest(!1)
	}
},
PRingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
PRingBufferGeometry.prototype.constructor = PRingBufferGeometry,
THREE.PRingBufferGeometry = PRingBufferGeometry,
THREE.RadialProgressMaterial = function(e) {
	var t = {
		max_radius: {
			value: e.max_radius || .9
		},
		min_radius: {
			value: e.min_radius || .8
		},
		progress: {
			value: 0
		},
		color: {
			value: e.color || new THREE.Color(16777215)
		},
		bg_color: {
			value: e.bg_color || new THREE.Color( - 1, 0, 0)
		}
	},
	i = new THREE.ShaderMaterial({
		uniforms: t,
		vertexShader: "\t\t\tvarying vec2 vUv;\t\t\t\t\t    void main() {\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\t\t\t\tvUv = uv;\t\t    }",
		fragmentShader: "\t  \t\tuniform vec3 color;\t  \t\tuniform vec3 bg_color;\t  \t\tuniform float min_radius;\t\t\tuniform float max_radius;\t\t\tuniform float progress;\t\t\t\t\t\tvarying vec2 vUv;\t  \t\t\t  \t\tfloat M_PI = 3.14159265359;\t  \t\tfloat alpha;\t  \t\t\t  \t\tvoid main() {\t\t\t\tfloat x = (vUv.x - 0.5) * 2.0;\t\t\t\tfloat y = (vUv.y - 0.5) * 2.0;\t\t\t\tfloat d = length( vec2(x,y) );\t\t\t\tif( d < min_radius || d > max_radius ) discard;\t\t\t\tfloat r = ( ( atan( -x, -y ) ) / M_PI + 1.0)/ 2.0;\t\t\t\tif( r <= progress ){\t\t\t\t\tgl_FragColor = vec4( color, 1.0 );\t\t\t\t}else{\t\t\t\t\tgl_FragColor = vec4( bg_color, bg_color.r == -1.0 ? 0.0 : 1.0 );\t\t\t\t}\t\t\t\t\t\t}",
		transparent: !0,
		depthTest: !1
	});
	return Object.defineProperties(i, {
		min_radius: {
			get: function() {
				return t.min_radius.value
			},
			set: function(e) {
				t.min_radius.value = e
			}
		},
		max_radius: {
			get: function() {
				return t.max_radius.value
			},
			set: function(e) {
				t.max_radius.value = e
			}
		},
		progress: {
			get: function() {
				return t.progress.value
			},
			set: function(e) {
				t.progress.value = e
			}
		},
		color: {
			get: function() {
				return t.color.value
			},
			set: function(e) {
				t.color.value = e
			}
		},
		bg_color: {
			get: function() {
				return t.bg_color.value
			},
			set: function(e) {
				t.bg_color.value = e
			}
		}
	}),
	i
};
var PNRM = PNRM || {};
PNRM.Calibration = function() {
	function e() {
		var e = Util.getLocalStorage("calibration");
		if (!e) return Util.setLocalStorage("calibration", ""),
		!1;
		if (e = JSON.parse(e), o.poseSensor_) {
			var t = o.poseSensor_.rotationFix;
			t.alpha = e.rotation.alpha,
			t.beta = e.rotation.beta,
			t.gamma = e.rotation.gamma
		}
		return ! 0
	}
	var t, i, n = this,
	o = PNRM_PLAYER;
	n.check = function(r, a, s) {
		if (!Util.isMobile() || !o.poseSensor_) return void(r && r());
		if (!Util.getLocalStorage("calibration") || s) {
			i = $("<div class='pano__clibrate-popup'>                    <p>" + PNRM.Translations.messageCalibrationRequest + "</p>                </div>"),
			o.$container.append(i);
			var l = $("<div class='pano__clibrate-button'>" + PNRM.Translations.buttonCalibrate + "</div>");
			i.append(l),
			l.click(function() {
				if (l.off(), c.off(), i.html("<p>" + PNRM.Translations.messageCalibrationInProgress + "</p>"), t = r, o.poseSensor_) o.poseSensor_.onDeviceMotionChange_EXT = n.collectData;
				else for (var e = 0; e < 150; e++) n.collectData({
					alpha: 0,
					beta: 0,
					gamma: 0
				},
				{})
			});
			var c = $("<div class='pano__clibrate-button'>" + PNRM.Translations.buttonCancel + "</div>");
			i.append(c),
			c.click(function() {
				l.off(),
				c.off(),
				i.remove(),
				a && a()
			})
		} else e() ? r && r() : n.check(r)
	};
	var r = [];
	n.collectData = function(n, a) {
		if (console.log("collectData: ", n), r.push({
			rotRate: n,
			accGravity: a
		}), r.length > 100) {
			o.poseSensor_ && (o.poseSensor_.onDeviceMotionChange_EXT = null);
			for (var s = {
				alpha: 0,
				beta: 0,
				gamma: 0
			},
			l = 0; l < r.length; l++) {
				var c = r[l],
				u = c.rotRate,
				h = Math.abs(u.alpha);
				h > s.alpha && (s.alpha = h);
				var d = Math.abs(u.beta);
				d > s.beta && (s.beta = d);
				var m = Math.abs(u.gamma);
				m > s.gamma && (s.gamma = m)
			}
			Util.setLocalStorage("calibration", '{"rotation":{"alpha":' + s.alpha + ',"beta":' + s.beta + ',"gamma":' + s.gamma + "}}"),
			e();
			i.html("<p>Калибровка завершена.</p>");
			var p = $("<div class='pano__text-button'>" + PNRM.Translations.buttonContinue + "</button>");
			i.append(p),
			p.click(function() {
				p.off(),
				i.remove(),
				t && (t(), t = null)
			}),
			r = []
		}
	}
};
var PNRM = PNRM || {};
PNRM.VR = function() {
	function e() {
		t.hideMenuTip()
	}
	var t = this,
	i = PNRM_PLAYER,
	n = $(".panorama"),
	o = $("body"),
	r = !1,
	a = new THREE.StereoEffect(i.renderer);
	a.setSize(window.innerWidth, window.innerHeight);
	t.calibration = new PNRM.Calibration;
	t.isVR = function() {
		return r
	},
	t.enableVR = function(t) {
		console.log("enableVR: ", r + " > " + t),
		r = t,
		t ? (i.POINTERS.showCrosshair(), i.switchControls(i.ORIENTATION, !0), s.show()) : (i.POINTERS.hideCrosshair(), i.switchControls(i.MOUSE), i.renderer.setSize(window.innerWidth, window.innerHeight), Util.removeEvent("up", n, e), s.hide()),
		o.toggleClass("is_vr", r).trigger("vr:change", r),
		i.fullscreenToggle(t)
	};
	var s = $(".brief__vr-exit-button").hide().click(function() {
		t.enableVR(!1)
	});
	t.render = function() {
		a.render(i.scene, i.camera)
	},
	t.setSize = function(e, t) {
		a.setSize(e, t)
	};
	var l = $("#pnrm-settings_fov  input");
	l.change(function(e) {
		var t = parseFloat(e.currentTarget.value);
		i.camera.fov = t,
		i.camera.updateProjectionMatrix()
	});
	var c = $("#pnrm-settings_focus  input");
	c.change(function(e) {
		var t = parseFloat(e.currentTarget.value);
		i.camera.focus = t,
		i.camera.updateProjectionMatrix()
	});
	var u = $("#pnrm-settings_eye-separation  input");
	u.change(function(e) {
		var t = parseFloat(e.currentTarget.value);
		a.setEyeSeparation(t)
	}),
	t.showVRSettings = function(e) {
		console.log("VRSettingsToggle: ", $(".menu-vr-settings")),
		void 0 == e ? el.toggle() : e ? el.show() : el.hide(),
		l.val(i.camera.fov),
		c.val(i.camera.focus),
		u.val(a.getEyeSeparation())
	};
	var h = $(".pano__vr-menu-tip");
	t.hideMenuTip = function() {
		h.is(":visible") && h.stop(!0).fadeTo(100, 0,
		function() {
			h.hide()
		})
	}
};
var PNRM = PNRM || {};
PNRM.VRHover = function(e) {
	var t = new THREE.PlaneGeometry(24, 24, 1),
	i = new THREE.RadialProgressMaterial({
		color: new THREE.Color("#04aa73"),
		max_radius: .9,
		min_radius: .84
	}),
	n = this.sprite = new THREE.Mesh(t, i);
	return n.position.set(0, 0, -100),
	n.lookAt(e.position),
	n.matrixAutoUpdate = !1,
	n.updateMatrix(),
	n.visible = !1,
	this.show = function(e, t) {
		n.position.copy(e),
		n.lookAt(new THREE.Vector3(0, 0, 0)),
		n.updateMatrix(),
		n.visible = !0,
		i.progress = 0,
		$(i).stop().animate({
			progress: 1
		},
		3e3, "linear",
		function() {
			console.log("animation done", t),
			t && t(),
			n.visible = !1
		})
	},
	this.hide = function() {
		n.visible = !1,
		$(i.offset).stop()
	},
	this
};
var PNRM = PNRM || {};
PNRM.Crosshair = function() {
	var e = this.sprite = new THREE.Object3D;
	e.position.set(0, 0, -2),
	e.scale.set(.01, .01, .01),
	e.visible = !1;
	var t = {
		uvs: [[]],
		faces: [3, 16, 17, 19, 18, 1, 3, 12, 10, 11, 13, 1, 3, 0, 1, 22, 23, 1, 3, 0, 3, 2, 1, 1, 3, 4, 2, 3, 5, 1, 3, 7, 6, 4, 5, 1, 3, 16, 6, 7, 17, 1, 3, 8, 9, 18, 19, 1, 3, 8, 11, 10, 9, 1, 3, 15, 14, 12, 13, 1, 3, 20, 14, 15, 21, 1, 3, 23, 22, 20, 21, 1, 3, 24, 25, 26, 27, 2, 3, 33, 28, 27, 32, 2, 3, 35, 24, 31, 34, 2, 3, 31, 28, 29, 30, 2, 3, 31, 24, 27, 28, 2],
		vertices: [ - 1, -1, 0, -.70614904, -.70488209, 0, -3.7061491, -.70614904, 0, -4, -1, 0, -3.7061491, .70614904, 0, -4, 1, 0, -.70614904, .70488214, 0, -1, 1, 0, 1, 1, 0, .70614904, .70488214, 0, 3.7061491, .70614904, 0, 4, 1, 0, 3.7061491, -.70614904, 0, 4, -1, 0, .70614904, -.70488209, 0, 1, -1, 0, -.70614904, 3.7061491, 0, -1, 4, 0, .70614904, 3.7061491, 0, 1, 4, 0, .70614904, -3.7061491, 0, 1, -4, 0, -.70614904, -3.7061491, 0, -1, -4, 0, -.70614904, -.70488209, 0, -3.7061491, -.70614904, 0, -3.7061491, .70614904, 0, -.70614904, .70488214, 0, .70614904, .70488214, 0, 3.7061491, .70614904, 0, 3.7061491, -.70614904, 0, .70614904, -.70488209, 0, -.70614904, 3.7061491, 0, .70614904, 3.7061491, 0, .70614904, -3.7061491, 0, -.70614904, -3.7061491, 0],
		materials: [{
			colorDiffuse: [.4000000059604645, .4000000059604645, .4000000059604645],
			depthWrite: !0,
			transparency: 1,
			blending: "NormalBlending",
			shading: "Lambert",
			DbgName: "lambert1",
			colorAmbient: [0, 0, 0],
			transparent: !1,
			depthTest: !0,
			vertexColors: !1
		},
		{
			colorDiffuse: [.31440001002550133, .31440001002550133, .31440001002550133],
			depthWrite: !0,
			transparency: 1,
			blending: "NormalBlending",
			shading: "Lambert",
			DbgName: "mCrosshairB",
			colorAmbient: [0, 0, 0],
			transparent: !1,
			depthTest: !0,
			vertexColors: !1
		},
		{
			colorDiffuse: [.800000011920929, .800000011920929, .800000011920929],
			depthWrite: !0,
			transparency: 1,
			blending: "NormalBlending",
			shading: "Lambert",
			DbgName: "mCrosshairW",
			colorAmbient: [0, 0, 0],
			transparent: !1,
			depthTest: !0,
			vertexColors: !1
		}],
		normals: [],
		metadata: {
			formatVersion: 3.1,
			generatedBy: "Maya Exporter"
		}
	},
	i = new THREE.MeshBasicMaterial({
		color: 16777215,
		side: THREE.DoubleSide
	});
	i.transparent = !0,
	i.opacity = .7;
	var n = i.clone();
	n.color = new THREE.Color(6710886);
	var o = new THREE.MultiMaterial([i, n, i]),
	r = new THREE.JSONLoader;
	THREE.upgradeGeoObject(t);
	var a = r.parse(t),
	s = new THREE.Mesh(a.geometry, o);
	return s.matrixAutoUpdate = !1,
	e.add(s),
	this.show = function() {
		e.visible = !0
	},
	this.hide = function() {
		e.visible = !1
	},
	this
};
var ROTATE_SPEED = .5;
TouchPanner.prototype.getOrientation = function() {
	return this.orientation.setFromEulerXYZ(0, 0, this.theta),
	this.orientation
},
TouchPanner.prototype.resetSensor = function() {
	this.theta = 0
},
TouchPanner.prototype.onTouchStart_ = function(e) {
	1 == e.touches.length && (this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY), this.isTouching = !0)
},
TouchPanner.prototype.onTouchMove_ = function(e) {
	if (this.isTouching) {
		this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY),
		this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart),
		this.rotateStart.copy(this.rotateEnd),
		Util.isIOS() && (this.rotateDelta.x *= -1);
		var t = document.body;
		this.theta += 2 * Math.PI * this.rotateDelta.x / t.clientWidth * ROTATE_SPEED
	}
},
TouchPanner.prototype.onTouchEnd_ = function(e) {
	this.isTouching = !1
},
ComplementaryFilter.prototype.addAccelMeasurement = function(e, t) {
	this.currentAccelMeasurement.set(e, t)
},
ComplementaryFilter.prototype.addGyroMeasurement = function(e, t) {
	this.currentGyroMeasurement.set(e, t);
	var i = t - this.previousGyroMeasurement.timestampS;
	Util.isTimestampDeltaValid(i) && this.run_(),
	this.previousGyroMeasurement.copy(this.currentGyroMeasurement)
},
ComplementaryFilter.prototype.run_ = function() {
	if (!this.isOrientationInitialized) return this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample),
	this.previousFilterQ.copy(this.accelQ),
	void(this.isOrientationInitialized = !0);
	var e = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS,
	t = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, e);
	this.gyroIntegralQ.multiply(t),
	this.filterQ.copy(this.previousFilterQ),
	this.filterQ.multiply(t);
	var i = new MathUtil.Quaternion;
	i.copy(this.filterQ),
	i.inverse(),
	this.estimatedGravity.set(0, 0, -1),
	this.estimatedGravity.applyQuaternion(i),
	this.estimatedGravity.normalize(),
	this.measuredGravity.copy(this.currentAccelMeasurement.sample),
	this.measuredGravity.normalize();
	var n = new MathUtil.Quaternion;
	n.setFromUnitVectors(this.estimatedGravity, this.measuredGravity),
	n.inverse();
	var o = new MathUtil.Quaternion;
	o.copy(this.filterQ),
	o.multiply(n),
	this.filterQ.slerp(o, 1 - this.kFilter),
	this.previousFilterQ.copy(this.filterQ)
},
ComplementaryFilter.prototype.getOrientation = function() {
	return this.filterQ
},
ComplementaryFilter.prototype.accelToQuaternion_ = function(e) {
	var t = new MathUtil.Vector3;
	t.copy(e),
	t.normalize();
	var i = new MathUtil.Quaternion;
	return i.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), t),
	i.inverse(),
	i
},
ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(e, t) {
	var i = new MathUtil.Quaternion,
	n = new MathUtil.Vector3;
	return n.copy(e),
	n.normalize(),
	i.setFromAxisAngle(n, e.length() * t),
	i
},
PosePredictor.prototype.getPrediction = function(e, t, i) {
	if (!this.previousTimestampS) return this.previousQ.copy(e),
	this.previousTimestampS = i,
	e;
	var n = new MathUtil.Vector3;
	n.copy(t),
	n.normalize();
	var o = t.length();
	if (o < 20 * MathUtil.degToRad) return this.outQ.copy(e),
	this.previousQ.copy(e),
	this.outQ;
	var r = (this.previousTimestampS, o * this.predictionTimeS);
	return this.deltaQ.setFromAxisAngle(n, r),
	this.outQ.copy(this.previousQ),
	this.outQ.multiply(this.deltaQ),
	this.previousQ.copy(e),
	this.outQ
},
SensorSample.prototype.set = function(e, t) {
	this.sample = e,
	this.timestampS = t
},
SensorSample.prototype.copy = function(e) {
	this.set(e.sample, e.timestampS)
};
var WebVRConfig = {
	FORCE_ENABLE_VR: !1,
	K_FILTER: .98,
	PREDICTION_TIME_S: .04,
	TOUCH_PANNER_DISABLED: !1,
	CARDBOARD_UI_DISABLED: !1,
	ROTATE_INSTRUCTIONS_DISABLED: !1,
	YAW_ONLY: !1,
	MOUSE_KEYBOARD_CONTROLS_DISABLED: !1,
	DEFER_INITIALIZATION: !1,
	ENABLE_DEPRECATED_API: !1,
	BUFFER_SCALE: .5,
	DIRTY_SUBMIT_FRAME_BINDINGS: !1
};
FusionPoseSensor.prototype.getPosition = function() {
	return null
},
FusionPoseSensor.prototype.getOrientation = function() {
	var e = this.filter.getOrientation();
	this.predictedQ = this.posePredictor.getPrediction(e, this.gyroscope, this.previousTimestampS);
	var t = new MathUtil.Quaternion;
	return t.copy(this.filterToWorldQ),
	t.multiply(this.resetQ),
	WebVRConfig.TOUCH_PANNER_DISABLED || t.multiply(this.touchPanner.getOrientation()),
	t.multiply(this.predictedQ),
	t.multiply(this.worldToScreenQ),
	WebVRConfig.YAW_ONLY && (t.x = 0, t.z = 0, t.normalize()),
	this.orientationOut_[0] = t.x,
	this.orientationOut_[1] = t.y,
	this.orientationOut_[2] = t.z,
	this.orientationOut_[3] = t.w,
	this.orientationOut_
},
FusionPoseSensor.prototype.resetPose = function() {
	this.resetQ.copy(this.filter.getOrientation()),
	this.resetQ.x = 0,
	this.resetQ.y = 0,
	this.resetQ.z *= -1,
	this.resetQ.normalize(),
	Util.isLandscapeMode() && this.resetQ.multiply(this.inverseWorldToScreenQ),
	this.resetQ.multiply(this.originalPoseAdjustQ),
	WebVRConfig.TOUCH_PANNER_DISABLED || this.touchPanner.resetSensor()
},
FusionPoseSensor.prototype.onDeviceOrientationChangeEvent_ = function(e) {
	console.log("deviceOrientation: ", e);
	var t = this.rotRate_orientation,
	i = this.rotCurrent_orientation;
	t.alpha = e.alpha - i.alpha,
	t.beta = e.beta - i.beta,
	t.gamma = e.gamma - i.gamma,
	i.alpha = e.alpha,
	i.beta = e.beta,
	i.gamma = e.gamma;
	var n = e.timeStamp / 1e3;
	this.isFirefoxAndroid && (n /= 1e3);
	var o = n - this.previousTimestampS;
	if (o <= Util.MIN_TIMESTEP || o > Util.MAX_TIMESTEP) return console.warn("Invalid timestamps detected. Time step between successive gyroscope sensor samples is very small or not monotonic"),
	void(this.previousTimestampS = n);
	this.accelerometer.set( - accGravity.x, -accGravity.y, -accGravity.z);
	var r = t.alpha;
	r = r >= 0 ? Math.max(0, r - this.rotationFix.alpha) : Math.min(0, r + this.rotationFix.alpha);
	var a = t.beta;
	a = a >= 0 ? Math.max(0, a - this.rotationFix.beta) : Math.min(0, a + this.rotationFix.beta);
	var s = t.gamma;
	s = s >= 0 ? Math.max(0, s - this.rotationFix.gamma) : Math.min(0, s + this.rotationFix.gamma),
	this.gyroscope.set(r, a, s),
	this.onDeviceMotionChange_EXT && this.onDeviceMotionChange_EXT(t, accGravity),
	(this.isIOS || this.isFirefoxAndroid) && this.gyroscope.multiplyScalar(MathUtil.degToRad),
	this.filter.addAccelMeasurement(this.accelerometer, n),
	this.filter.addGyroMeasurement(this.gyroscope, n),
	this.previousTimestampS = n
},
FusionPoseSensor.prototype.onDeviceMotionChange_ = function(e) {
	var t = e.accelerationIncludingGravity,
	i = e.rotationRate,
	n = e.timeStamp / 1e3;
	this.isFirefoxAndroid && (n /= 1e3);
	var o = n - this.previousTimestampS;
	if (o <= Util.MIN_TIMESTEP || o > Util.MAX_TIMESTEP) return console.warn("Invalid timestamps detected. Time step between successive gyroscope sensor samples is very small or not monotonic"),
	void(this.previousTimestampS = n);
	this.accelerometer.set( - t.x, -t.y, -t.z);
	var r = i.alpha;
	r = r >= 0 ? Math.max(0, r - this.rotationFix.alpha) : Math.min(0, r + this.rotationFix.alpha);
	var a = i.beta;
	a = a >= 0 ? Math.max(0, a - this.rotationFix.beta) : Math.min(0, a + this.rotationFix.beta);
	var s = i.gamma;
	s = s >= 0 ? Math.max(0, s - this.rotationFix.gamma) : Math.min(0, s + this.rotationFix.gamma),
	this.gyroscope.set(r, a, s),
	this.onDeviceMotionChange_EXT && this.onDeviceMotionChange_EXT(i, t),
	(this.isIOS || this.isFirefoxAndroid) && this.gyroscope.multiplyScalar(MathUtil.degToRad),
	this.filter.addAccelMeasurement(this.accelerometer, n),
	this.filter.addGyroMeasurement(this.gyroscope, n),
	this.previousTimestampS = n
},
FusionPoseSensor.prototype.onScreenOrientationChange_ = function(e) {
	console.log("$ onScreenOrientationChange_"),
	this.setScreenTransform_()
},
FusionPoseSensor.prototype.setScreenTransform_ = function() {
	switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
	case 0:
		break;
	case 90:
		this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
		break;
	case - 90 : this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2)
	}
	this.inverseWorldToScreenQ.copy(this.worldToScreenQ),
	this.inverseWorldToScreenQ.inverse()
};